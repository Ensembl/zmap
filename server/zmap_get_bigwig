#!/usr/bin/env perl

use strict;
use warnings;

use Carp;
use Getopt::Long 'GetOptions';
use Pod::Usage;
use Roman;

use URI::Escape qw(uri_unescape);

use Bio::DB::BigWig;
use Bio::Server::BigWig;


# parameters
my %params = ();

my @options = qw(
    help!
    man!
    gff_version=i
    file=s
    seq_id=s
    start=i
    end=i
    gff_feature_source=s
    strand=s
    gff_seqname=s
    roman!
    Roman!
    mapto=i
    );

my @required = qw(
    file
    seq_id
    start
    end
    gff_feature_source
    strand
    );

my $attributes_format;
my $strands = { 1  => '+', -1 => '-' };
my $sequence;
my $strand_field;
my $source;


sub get_params
{
    # defaults
    $params{'gff_version'} = 2; # default for now as ZMap doesn't do v3 yet

    GetOptions(\%params, @options ) or pod2usage(2);

    pod2usage(1) if defined $params { 'help' };
    pod2usage(-exitstatus => 0, -verbose => 2) if defined $params {'man'} ;

    my $missing = 0;
    foreach my $param (@required) {
        if (!defined $params { $param }) {
            print "$param not specified\n";
            $missing++;
        }
    }
    pod2usage(1) if $missing;

    $strand_field = ($params{'strand'} == 1 ) ? '+' : ($params{'strand'} == -1 ) ? '-' : '.';

    $params{'seq_id'} = Roman($params{'seq_id'}) if defined $params{'Roman'};
    $params{'seq_id'} = roman($params{'seq_id'}) if defined $params{'roman'};

    if (defined $params{'gff_seqname'}) {
        $sequence = $params{'gff_seqname'};
    }
    else {
        $sequence = $params{'seq_id'};
    }

    $attributes_format = $params{'gff_version'} == 3 ? '%s=%s' : '%s %s';

    return;
}


sub print_header
{
    printf "##gff-version %d\n##sequence-region %s %d %d\n", $params{'gff_version'}, $sequence, $params{'start'}, $params{'end'};
    return;
}


sub gff_escape {
    # escapes a minimal set of characters
    s/([\t\r\n[:cntrl:];=%&])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_seqid {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_?|])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_source {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_? ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_attribute {
    # like gff_escape, but escapes commas too
    s/([\t\r\n[:cntrl:];=%&,])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_target {
    # like gff_escape, but escapes commas and spaces too
    s/([\t\r\n[:cntrl:];=%&, ])/sprintf "%%%02X", ord($1)/eg;
    return;
}


sub print_feature {
    my ($feature, $start, $end) = @_;

    my @fields =
        (
         'region',
         (sprintf "%d", $start),
         (sprintf "%d", $end),
         abs($feature->score),
         $strand_field,
         '.', # phase, undefined
         '', # attributes, empty
        );

    gff_escape for @fields;
    printf "%s\n", join "\t", $sequence, $source, @fields;

    return;
}



=begin comment

# get the mapping from the Otter server
my $client = Bio::Otter::Lace::Defaults::make_Client();
my $mapping_xml = $client->otter_response_content(
    'GET', 'get_mapping', {
        dataset => $dataset,
        cs      => $csver,
        seq_id  => $seq_id,
        start   => $start,
        end     => $end,
    });
my $mapping = Bio::Otter::Mapping->new_from_xml($mapping_xml);

# map and print the features
_print_header;
$mapping->do_features($bam_fetch, $start, $end, \&_print_feature);

=cut


sub main
{
    get_params();

    my $seq_id = $params{'seq_id'};
    gff_escape_seqid for $sequence;

    $source = $params{'gff_feature_source'};
    gff_escape_source for $source;

    my $bigwig = Bio::DB::BigWig->new( -bigwig => $params{'file'} );
    my $bigwig_fetch = Bio::Server::BigWig->new( -bigwig => $bigwig );

    # map first then request.... move this to inside the mapping function
    my $features = $bigwig_fetch->features( $seq_id, $params{'start'}, $params{'end'});

# if it's a ref
#   printf "found %d matches\n", scalar @{$$features}  ;
    printf STDERR "found %d matches\n", scalar @{$features}  ;

    print_header();

    foreach my $feat (@{$features}) {
        print_feature($feat, $feat->start, $feat->end);
    }

    return;
}

main;

__END__

=head1 NAME

zmap_get_bigwig request coverage data and output as GFF

=head1 SYNOPSIS

zmap_get_bigwig [--help] [--man] --file=[http:|ftp:]/path/to/file --start=123 --end=456 --gff_feature_source=name --seq_id=CHROMOSOME_IV --strand=1 [--gff_version=3]  [--roman] [--Roman] --gff_seqname=sequence

=head1 OPTIONS

=over 8

=item B<-help>
Print a brief help message and exits.
=item B<-man>
Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<This program> will read the given input file(s) and do someting
useful with the contents thereof.

=head1 COPYRIGHT

 Copyright (c) 2006-2012: Genome Research Ltd.
------------------------------------------------------------------
ZMap is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
or see the on-line version at http://www.gnu.org/copyleft/gpl.txt
------------------------------------------------------------------
This file is part of the ZMap genome database package
originated by
     Ed Griffiths (Sanger Institute, UK) edgrif@sanger.ac.uk,
       Roy Storey (Sanger Institute, UK) rds@sanger.ac.uk,
  Malcolm Hinsley (Sanger Institute, UK) mh17@sanger.ac.uk
------------------------------------------------------------------
This script was derived fron an Anacode script believed to have been
written originally by Jeremy Henty (jh13@sanger.ac.uk)

=head1 AUTHOR

Malcolm Hinsley B<email> mh17@sanger.ac.uk
