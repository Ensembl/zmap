#!/usr/bin/env perl

# copied from Otterlace script bam_get_align and ammedned by mh17 to be otterlace free
# you do however have to provide Bio::DB::Sam, i'm using the otterlace build for testing

use strict;
use warnings;

use Carp;
use Getopt::Long 'GetOptions';
use Pod::Usage;
use Roman;

use URI::Escape qw(uri_unescape);

use Bio::DB::Sam;
use Bio::Server::BAM;


# parameters
my %params = ();
my @options = qw ( help! man! gff_version=i file=s chr=s start=i end=i gff_feature_source=s gff_seqname=s roman! Roman! mapto=i);
my @required = qw ( file chr start end gff_feature_source );

my $attributes_format;
my $attributes_sep = ';';
my $strands = { 1  => '+', -1 => '-' };
my $source;
my $sequence;


sub get_params
{
 	# defaults
	$params {'gff_version'}= 2;		# default for now as ZMap doesn't do v3 yet

	GetOptions(\%params, @options ) or pod2usage(2);

	pod2usage(1) if defined $params { 'help' };
	pod2usage(-exitstatus => 0, -verbose => 2) if defined $params {'man'} ;

	my $missing = 0;
	foreach my $param (@required)
	{
		if (!defined $params { $param })
		{
			print "$param not specified\n";
			$missing++;
		}
	}
	pod2usage(1) if $missing;

	$params{$_} = uri_unescape($params{$_}) for keys %params;

	$params { 'chr' } = Roman($params { 'chr' }) if(defined $params { 'Roman' });
	$params { 'chr' } = roman($params { 'chr' }) if(defined $params { 'roman' });

	if(defined $params { 'gff_seqname' })
	{
		$sequence = $params { 'gff_seqname' };
	}
	else
	{
		$sequence = $params {'chr'};
	}

	if($params { 'gff_version' } == 2)
	{
		$attributes_format ='%s %s';
		$attributes_sep = ' ; ';
	}
	else
	{
		$attributes_format = '%s=%s';
		$attributes_sep = ';';
	}
}


sub print_header
{
    printf "##gff-version %d\n##sequence-region %s %d %d\n", $params { 'gff_version' }, $sequence, $params { 'start' }, $params { 'end' } ;
    return;
}


sub gff_escape {
    # escapes a minimal set of characters
    s/([\t\r\n[:cntrl:];=%&])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_seqid {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_?|])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_source {
    # escapes everything except a restricted set of characters
    s/([^-a-zA-Z0-9.:^*$@!+_? ])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_attribute {
    # like gff_escape, but escapes commas too
    s/([\t\r\n[:cntrl:];=%&,])/sprintf "%%%02X", ord($1)/eg;
    return;
}

sub gff_escape_target {
    # like gff_escape, but escapes commas and spaces too
    s/([\t\r\n[:cntrl:];=%&, ])/sprintf "%%%02X", ord($1)/eg;
    return;
}


sub print_feature {
    my ($feature, $start, $end) = @_;

    my $name = $feature->name;
    gff_escape_target for $name;

    # the --source flag overrides the source from the BAM file
	# No: the BAM source is usually a bit useless
    # my $source = $params { 'source' } ; # || $feature->source_tag;

    my ($score) = $feature->get_tag_values('AS');

    my @fields =
        (
         $params { 'gff_version' } == 2 ? 'similarity' : 'read',
         (sprintf "%d", $start),
         (sprintf "%d", $end),
         (defined $score ? (sprintf "%f", $score) : '.'),
         $strands->{$feature->strand},
         $feature->phase || '.',
        );

    # $feature->cigar_str has the wrong format for the Gap tag
    # (eg. 76M instead of M76) so we have to build it from
    # $feature->cigar_array (which, strangely, has the operator
    # and count arguments in the right order for the Gap tag even
    # though $feature->cigar_str has them in the wrong order)

    # the Target tag - escaping this requires special handling of
    # spaces in the query name

    my $query = $feature->query;

    my @align_fields = ($query->start, $query->end);
    my $query_strand = $strands->{$query->strand};
    push @align_fields, $query_strand if $query_strand;

    my $q_length = $feature->l_qseq;
    my @attributes;

    if($params { 'gff_version' } == 2)
    {
	  @attributes = (
        Class       => qq{"Sequence"},
        Name        => qq{"$name"},
        Align       => join(' ', @align_fields),
        Length      => $feature->l_qseq,
        percentID   => 100,
        sequence    => $query->dna
        );
    }
    else
    {
	  @attributes = (
        name        => $name,
	  Target	  =>join(' ', ($name, @align_fields) ),
        percentID   => 100,
        sequence    => $query->dna
        );
    }

    my $cigar = $feature->cigar_str;
    $cigar =~ s/\d+S//g;    # Remove BAM "S" clipping strings from CIGAR
    if ($cigar !~ /^\d+M$/)
    {
	if($params { 'gff_version' } == 2)
	{
		# It isn't a simple match string, so we do need CIGAR
		push(@attributes, cigar_bam => qq{"$cigar"});
	}
	else
	{
		$cigar =~ s/(\d+)(\D+)/$2$1 /g;
		push(@attributes, 'Gap' => $cigar );

	}
    }

    my @attribute_strings = ();
    while ( my ($key, $value) = splice(@attributes, 0, 2) ) {
        push @attribute_strings, sprintf $attributes_format, $key, $value;
    }
    my $attributes_string = join $attributes_sep, @attribute_strings;

    gff_escape_source for $source;
    gff_escape for @fields;
    print join("\t", $sequence, $source, @fields, $attributes_string), "\n";

    return;
}

=begin comment
GFF 3 format example
CHR1-14	Tier1_H1-hESC_cell_longPolyA_rep2	read	551303	897076	.	+	.	Name=MARILYN_0005:4:110:14188:19321#0/1;Gap=M8 N345698 M68;Target=MARILYN_0005:4:110:14188:19321#0/1 1 76 +;sequence=GTTCACAAATGAGATGAGCGAGAGCCGCCAGACCCACGTGACGCTGCACGACATCGACCCTCAGGCCTTGGACCAG
=cut


=begin comment

# get the mapping from the Otter server
my $client = Bio::Otter::Lace::Defaults::make_Client();
my $mapping_xml = $client->otter_response_content(
    'GET', 'get_mapping', {
        dataset => $dataset,
        cs      => $csver,
        chr     => $chr,
        start   => $start,
        end     => $end,
    });
my $mapping = Bio::Otter::Mapping->new_from_xml($mapping_xml);

# map and print the features
_print_header;
$mapping->do_features($bam_fetch, $start, $end, \&_print_feature);

=cut


sub main
{
	get_params();

	my $chr = $params { 'chr' } ;
	gff_escape_seqid for $sequence;

	$source = $params { 'gff_feature_source' };
	gff_escape_source for $source;

	my $sam = Bio::DB::Sam->new
	(
		-bam   => uri_unescape($params { 'file' }),
		# -fasta => $fasta_path,
	);

	my $bam_fetch = Bio::Server::BAM->new
	(
		-sam        => $sam
	);


	# map first then request.... move this to inside the mapping function
	my $features = $bam_fetch->features ( $chr, $params { 'start' },  $params { 'end' } );

# if it's a ref
#	printf "found %d matches\n", scalar @{$$features}  ;
	printf STDERR "found %d matches\n", scalar @{$features}  ;

	print_header();

	foreach my $feat (@{$features})
	{
		print_feature($feat, $feat->start, $feat->end );
	}
}

main;

__END__

=head1 NAME

zmap_get_bam request data and output as GFF

=head1 SYNOPSIS

zmap_get_bam [--help] [--man] --file=[http:|ftp:]/path/to/file --start=123 --end=456 --gff_feature_source=name --chr=CHROMOSOME_IV [--gff_version=3] --gff_seqname=GFF_sequence_name [--roman] [--Roman] --mapto=offset

=head1 OPTIONS

=over 8

=item B<-help>
Print a brief help message and exits.
=item B<-man>
Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<This program> will read the given input file(s) and generate GFF output as requested

=head1 COPYRIGHT

 Author: Malcolm Hinsley (mh17@sanger.ac.uk)
 Copyright (c) 2006-2012: Genome Research Ltd.
------------------------------------------------------------------
ZMap is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
or see the on-line version at http://www.gnu.org/copyleft/gpl.txt
------------------------------------------------------------------
This file is part of the ZMap genome database package
originated by
     Ed Griffiths (Sanger Institute, UK) edgrif@sanger.ac.uk,
       Roy Storey (Sanger Institute, UK) rds@sanger.ac.uk,
  Malcolm Hinsley (Sanger Institute, UK) mh17@sanger.ac.uk
------------------------------------------------------------------
This script was derived fron an Anacode script believed to have been
written originally by Jeremy Henty (jh13@sanger.ac.uk)



