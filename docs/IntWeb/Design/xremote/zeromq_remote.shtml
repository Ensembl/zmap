<!--#set var="banner" value="The Remote Control Interface using ZeroMQ"-->
<!--#include virtual="/perl/header"-->

<!--#set var="author" value="mg13@sanger.ac.uk" -->

<!-- some colours for our boxes etc. -->

<!-- lightpink = #FFB8C1 -->

<style>

pre{ background-color: #DDDDDD; border-style: solid; border-width: 1px; padding: 10px }

.code{ background-color: lightsteelblue }
.request{ border-color: red;  border-width: medium }
.reply{ border-color: green; border-width: medium }
.message{ border-color: blue; border-width: medium }

table.zmap_actions{ background-color: #EFEFEF; border-width: 1px; border-style: solid; border-collapse: collapse }
table.zmap_actions td{ border-width: 0px 1px 1px 0px; border-style: solid; padding: 2px }
table.zmap_actions tr{ vertical-align: top; }
table.zmap_actions th{ border-width: 0px 0px 1px 0px; border-style: solid; }

fieldset
{
background-color: lightblue;
border-style: solid; border-width: 3px; border-color: black;
padding: 10px
}

legend{ font-weight: bold }

</style>


<h1 align="center">ZMap Remote Control Interface using ZeroMQ</h1>


<h2>Contents</h2>

<ul>
  <li><a href="#introduction"><b>Introduction</b></a></li>
  <li><a href="#protocol"><b>The Request/Reply Transport Protocol</b></a></li>
  <li><a href="#problems"><b>Bootstrapping, Collisions, Synchronisation and Hanging</b><a></li>
  <li><a href="#collisions"><b>Collision Protocol</b></a></li>
  <li><a href="#timeouts"><b>Timeout Handling</b></a></li>
  <li><a href="#state"><b>State</b></a></li>
  <li><a href="#header"><b>Message Header</b></a></li>
  <li><a href="#references"><b>References</b></a></li>
  <li><a href="#otterlace_zmap">Appendix: Otterlace &amp; ZMap</a></li>
  <li><a href="#collisions_abort">Appendix: Collision Protocol with abort</a></li>
</ul>



<a name="introduction"></a>
<h2>Introduction</h2>

<p>This document describes how
the <a href="zmap_remote.shtml#protocol">Request/Reply Transport
Protocol</a> can be re-implemented using
the <a href="http://zeromq.org">ZeroMQ</a> networking library.</p>

<p>It would be helpful to have read the preface of
the <a href="http://zguide.zeromq.org/page:all">ZeroMQ Guide</a> and the
first few sections of chapter 1, up to and
including <em><a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive">Ask
and Ye Shall Receive</a></em>.</p>

<a name="protocol"></a>
<h2>The Request/Reply Transport Protocol</h2>

<h3>Peer States in the Request/Reply cycle:</h3>

<p>The simplified state changes are:</p>

<img src="./ZeroMQ_Request_Response_state.png" align="center">

<h3>ZeroMQ Endpoints</h3>

<p>The clipboard IDs used as endpoint identifiers in the X selection
transport are replaced with ZeroMQ endpoint addresses. These can
either be TCP sockets bound to the local interface (for single-machine
operation) or Unix domain sockets bound to a temporary file path.</p>

<h3>ZeroMQ Request/Reply cycle</h3>

<p>The following is simplified by ignoring the setting up of a ZeroMQ
context, and does not describe ZeroMQ message management.</p>

<p>To avoid confusion, henceforth the term <em>zmq_socket</em> is used
to refer to a ZeroMQ socket as opposed to a traditional Unix or TCP
socket.</p>

<img src="./ZeroMQ_Request_Reply.png" align="center">

<h3>Preparation for communications:</h3>

<ol>
  <li><p>Peer 1 creates a <tt>ZMQ_REQ</tt> client zmq_socket and connects it
  to Peer 2's endpoint via <tt>zmq_connect()</tt>.</p></li>

  <li><p>Peer 2 creates a <tt>ZMQ_REP</tt> server zmq_socket and binds this
  to its own endpoint via <tt>zmq_bind()</tt>. Peer 2 then arranges a
  callback on receive events for this zmq_socket.</p></li>
</ol>

<p>Note that ZeroMQ permits steps 1 and 2 to happen in either order.

<h3>Request and reply:</h3>

<ol start="3">
  <li><p>Peer 1 creates a request and sends it via its client zmq_socket by
  calling <tt>zmq_send()</tt>.</p></li>
  <li><p>Peer 2's server zmq_socket callback is fired, and
  uses <tt>zmq_recv</tt> to fetch the request.</p></li>
  <li><p>Peer 1 polls for, or arranges a callback on, a reply on its
  client zmq_socket. (A callback could be set up at any stage after the
  zmq_socket has been connected.)</p></li>
  <li><p>Peer 2 does some processing on the request (this should be
  brief).</p></li>
  <li><p>Peer 2 creates a reply and sends it via its server zmq_socket by
  calling <tt>zmq_send()</tt>.</p></li>
  <li><p>Peer 1's client zmq_socket callback or poll is fired, and
  uses <tt>zmq_recv()</tt> to fetch the reply.</p></li>
  <li><p>The request-reply sequence is complete, and can be repeated
  from step 3 when next required.</p></li>
</ol>

<a name="problems"></a>
<h2>Bootstrapping, Collisions, Synchronisation and Hanging</h2>

<p><b>Under construction.</b></p>

<h3>Bootstrapping</h3>

<p>Bootstrapping is almost identical to the existing system. The
initiator passes its server endpoint to its peer as a command line
parameter, which responds with its own server endpoint in a handshake
request message.</p>

<h3>Collisions</h3>

<p>Provided that when sending, the client also monitors its server
zmq_socket whilst waiting for a reply, collision detection should be
straightforward.</p>

<p>The simplified state diagram probably reduces the likelihood and
impact of collisions. None-the-less,
the <a href="#collisions">collision protocol</a> below allows safe
resolution.</p>

<h3>Timeouts and errors</h3>

<p>Timeouts and errors are to be handled by each client implementing
the <a href="http://zguide.zeromq.org/page:all#toc89">Lazy Pirate
Pattern</a>. See <a href="#timeouts">Timeout Handling</a> below.</p>

<p>The implications of the resulting likelihood of client
retries are discussed in the 'Synchronisation' sub-section.</p>

<h3>Synchronisation</h3>

<p>The client knows for certain that the server has received its
request when it receives the ZeroMQ reply.</p>

<p>The server does not know for certain that its ZeroMQ reply has
reached the client. This is an acceptable tradeoff compared with the
likely complexity of more handshaking, but leads to the following
alternative scenarios:</p>

<ul>
  <li><p>If server actions are idempotent, or else can be repeated at
  acceptable cost without resulting in an erroneous application state,
  then no special measures are required.</p></li>
  <li>
    <p>Otherwise, the latest reply message should be cached and the
    server should resend it if the current request's sequence number
    matches that of the cached reply.</p>
    <p>Note that this will require the transport / connection layer to
    process the message sequence numbers. This may be best handled by
    using multipart ZeroMQ messages
    (<a href="http://zguide.zeromq.org/page:all#toc36">http://zguide.zeromq.org/page:all#toc36</a>)
    to preserve and pass the XML from the higher layers, unchanged and
    not inspected by the transport layer.</p>
  </li>
</ul>

<a name="collisions"></a>
<h2>Collision Protocol</h2>

<p>The state diagram including collision detection, from the perspective of peer one:</p>

<img src="./ZeroMQ_Collision_state.png" align="center">

<h3>Detection and arbitration</h3>

<ol>
  <li><p>Peer 1 send a request, and then monitors for a reply, whilst
  also monitoring for an inbound request. <em>[Peer 2: also event 1]</em></p></li>
  <li>
    <p>Peer 2 sends a simultaneous request, which peer 1 detects and
    receives as a colliding request.</p>
    <p>Peer 1 compares the timestamp of the received request against
    its cached timestamp for its sent request.</p>
    <ul>
      <li><p>If peer 1 sent <em>before</em> peer 2, it wins the
      collision. (Continue at step 3.)</p></li>
      <li><p>If peer 1 sent <em>after</em> peer 2, it loses the
      collision. (Continue at step 10.)</p></li>
      <li><p>In the unlikely event that both timestamps are identical,
      the master wins, where the master is the peer which originally
      sent its endpoint address via the commandline to the
      slave.</p></li>
    </ul>
    <p><em>[Peer 2: also event 2]</em></p>
  </li>
</ol>

<h3>Collision winner</h3>

<p>Peer 1 wins.</p>

<ol start="3">
  <li><p>The winner's request stands, so the winner waits for a
  reply. <em>[Peer 2: event 10]</em></p></li>
  <li><p>The reply is received from the loser. <em>[Peer 2: event
  11]</em></p></li>
  <li><p>The losing request is now processed by the winner
  as usual. <em>[Peer 2: CLIENT_WAITING/normal]</em></p></li>
  <li><p>The winner replies to the losing request as normal.
         <em>[Peer 2: event 12.]</em></p></li>
</ol>

<img src="./ZeroMQ_Req_Rep_coll_win.png" align="center">

<h3>Collision loser</h3>

<p>Peer 1 loses.</p>

<ol start="10">
  <li><p>The loser cancels timeouts on its request (but leaves the
  request pending) and then processes the winning request as
  usual. <em>[Peer 2: event 3, CLIENT_WAITING/collision_win.]</em>
  </p></li>
  <li><p>The reply to the winning request is returned
  normally. <em>[Peer 2: event 4.]</em></p></li>
  <li><p>The loser now waits for the reply to its losing request as
  usual, restarting its request timeout from 0.
  <em>[Peer 2: event 5.]</em></p></li>
  <li><p>The winner replies to the losing request as normal.
      <em>[Peer 2: event 6.]</em></p></li>
</ol>

<a name="timeouts"></a>
<h2>Timeout Handling</h2>

<p>The sequence diagram including a client timeout, from the perspective of peer one:</p>

<img src="./ZeroMQ_Req_Rep_timeout.png" align="center">

<ol>
  <li><p>Peer 1 makes a new request with sequence id 203. It keeps a
  copy of the request in case of problems.</p></li>
  <li><p>Peer 2 receives request 203. At this stage it can discard
  response 202. It starts to process the new request.</p></li>
  <li><p>Peer 2 has finished processing request 203 and has created
  response 203. It keeps a copy of response 203 in case of
  problems.</p></li>
  <li><p>Peer 2 replies with its response.</p></li>
  <li><p>Unfortunately peer 2's processing has been too slow, so peer
  1 has timed out. It tears down and recreates its ZeroMQ REQ/REP
  connection to peer 1, and resends request 203.</p></li>
  <li><p>ZeroMQ discards the original reply.</p></li>
  <li><p>Peer 2 receives the repeat request 203.</p></li>
  <li><p>As it has kept a copy, there is no need to repeat the
  original processing.</p></li>
  <li><p>Peer 2 replies with its stored copy of response 203.</p></li>
  <li><p>Peer 1 receives the response. At this stage it can mark
  request 203 as acknowledged and can discard the stored
  request.</p></li>
</ol>

<h3>Notes</h3>

<ul>
  <li><p>If request processing involves returning to the event loop,
  the server (peer 2 in the example above) should suspend callbacks on
  its <code>ZQM_REP</code> server zmq_socket whilst it is processing the
  request, to prevent nested requests. ZeroMQ will buffer any incoming
  requests. Once the process-and-reply sequence is complete, the
  callback should be reinstated.</p></li>
  <li><p>Collison processing is not shown here but should proceed as
  normal. If the server has issued a new request which clashes with
  the client's resend, the resend will win as its timestamp will be as
  for the original request.</p></li>
  <li><p>To allow for the situation where the remote peer is busy
  processing, without requiring too many timeout and rety attempts,
  successive timeout intervals should increase exponentially. The
  proposed intervals are:
    <blockquote>
      333ms, 1000ms, 3000ms, 9000ms, <em>FAIL</em>
    </blockquote>
  giving a total grace period or 'processing window' to the remote
  peer of about 13 seconds.
  </p></li>
</ul>


<a name="state"></a>
<h2>State</h2>

<p>The server is required to keep:
<ul>
  <li><p>the request ID for the last request</p></li>
  <li><p>a copy of the reply to the last request</p></li>
</ul>
until a new request (with incremented request ID) is received.</p>

<p>This allows the server to reply to repeat requests issued as a
result of the client's timeout handling, without needing to re-process
the request.</p>

<p>Repeat requests for earlier requests are not expected and will not
be handled. (To do so would require a sliding window system.)</p>


<a name="header"></a>
<h2>Message header</h2>

<h3>Header fields</h3>

<p>The minimum set of fields for the message header is:</p>
<dl>
  <dt><em>Request-id</em></dt>
  <dd>The id of this request. Should be unique for each request, and
  should be incremented after each successful or aborted request.</dd>

  <dt><em>Clock-sec</em></dt>
  <dd>The whole-seconds portion of the system clock at the time the
  request was <b>first issued</b>.</dd>

  <dt><em>Clock-usec</em></dt>
  <dd>The microseconds portion of the system clock at the time the
  request was <b>first issued</b>.<br />
  Could be combined with <em>Clock-sec</em> to create a floating
  point <em>Clock</em> field, or a pure microseconds field.</dd>
</dl>

<p>Optional fields which could aid debugging but which are not
required for protocol operation:</p>
<dl>
  <dt><em>Request-attempt</em></dt>
  <dd>The retransmit attempt for this request. Should start at 1 and
  should be incremented on each retransmission.</dd>
</dl>

<h3>Suggested serialisation format</h3>

<p>Serialisation of the header does not warrant XML. ZeroMQ partitions
the header into a separate frame, which can use any appropriate
serialisation.</p>

<p>
  A suggested single-line format is:<br />
  <code>&lt;Request-id&gt;/&lt;Request-attempt&gt; &lt;Clock-sec&gt;,&lt;Clock-usec&gt;</code>
</p>

<p>
  For example, for
  <em>Request-id: 334, Request-attempt: 1, Clock:
  1145.232507</em><br /> the header is:<br />
  <code>334/1 1145,232507</code>
</p>


<a name="references"></a>
<h2>References</h2>

<ul>
  <li><a href="http://zeromq.org/">ZeroMQ</a></li>
  <li><a href="http://zguide.zeromq.org/page:all">ZeroMQ Guide</a></li>
  <li><a href="https://metacpan.org/pod/ZMQ::LibZMQ3">ZMQ::LibZMQ3 perl module</a></li>
</ul>


<a name="otterlace_zmap"></a>
<h2>Appendix: Otterlace &amp; ZMap</h2>

<ul>
  <li><p>Appropriate paths for Unix domain zmq_sockets would
  be <code>/var/tmp/otter_${USER}/${NUMBER}/0mq_{otter,zmap}</code>. Thanks
  to Matthew for this suggestion.</p></li>
</ul>


<a name="collisions_abort"></a>
<h2>Appendix: Collision Protocol with abort</h2>

<p>It is possible that the loser in a collision, having processed the
winner's request, changes state sufficiently that it now wishes to
retract its losing request. The following modifications allow for
this, although it is not proposed to implement the modified system
unless proved to be required.</p>

<p>The state diagram including collision detection and abort handling,
from the perspective of peer one:</p>

<img src="./ZeroMQ_Collision_state_abort.png" align="center">

<h3>Detection and arbitration</h3>

<ol>
  <li><p>Peer 1 send a request, and then monitors for a reply, whilst
  also monitoring for an inbound request. <em>[Peer 2: also event 1]</em></p></li>
  <li>
    <p>Peer 2 sends a simultaneous request, which peer 1 detects and
    receives as a colliding request.</p>
    <p>Peer 1 compares the timestamp of the received request against
    its cached timestamp for its sent request.</p>
    <ul>
      <li><p>If peer 1 sent <em>before</em> peer 2, it wins the
      collision. (Continue at step 3.)</p></li>
      <li><p>If peer 1 sent <em>after</em> peer 2, it loses the
      collision. (Continue at step 10.)</p></li>
      <li><p>In the unlikely event that both timestamps are identical,
      the master wins, where the master is the peer which originally
      sent its endpoint address via the commandline to the
      slave.</p></li>
    </ul>
    <p><em>[Peer 2: also event 2]</em></p>
  </li>
</ol>

<h3>Collision winner (with abort handling)</h3>

<p>Peer 1 wins.</p>

<ol start="3">
  <li><p>The winner's request stands, so the winner waits for a
  reply. <em>[Peer 2: events 10, 11]</em></p></li>
  <li><p>Once the reply is received, the winner examines the header to
  see if the loser wants to abort its colliding request.</p></li>
  <li><p>Assuming no abort, the losing request is now processed
  as usual. <em>[Peer 2: event 12, CLIENT_WAITING/normal]</em></p></li>
  <li>
    <p>The winner replies to the losing request as normal. <em>[Peer
    2: event 13.]</em></p>
    <p><em>or</em></p>
  </li>
  <li><p>If the loser has signalled abort, the winner does not reply
  and returns directly to INACTIVE. <em>[Peer 2: event
  14.]</em></p></li>
</ol>

<img src="./ZeroMQ_Req_Rep_coll_win_abort.png" align="center">

<h3>Collision loser (with abort handling)</h3>

<p>Peer 1 loses.</p>

<ol start="10">
  <li><p>The loser cancels timeouts on its request (but leaves the
  request pending) and then processes the winning request as
  usual. <em>[Peer 2: event 3,
  CLIENT_WAITING/collision_win.]</em></p></li>
  <li><p>The loser can optionally, on the basis of processing the
  winning request, decide to abort its losing request. It indicates
  this in the header of its reply to the winning request, which is
  otherwise returned normally. <em>[Peer 2: event 4.]</em></p></li>
  <li><p>Assuming the loser is not aborting its request, it now waits for
  the reply to its losing request as usual, restarting its request
  timeout from 0. <em>[Peer 2: event 5.]</em></p></li>
  <li>
    <p>The winner replies to the losing request as normal. <em>[Peer
    2: event 6.]</em></p>
    <p><em>or</em></p>
  </li>
  <li><p>If the loser is aborting its request, it closes and reopens its
  client zmq_socket (which would otherwise be awaiting a reply), and
  returns directly to INACTIVE. <em>[Peer 2: event 7.]</em></p></li>
</ol>



<!--#include virtual="/perl/footer"-->
