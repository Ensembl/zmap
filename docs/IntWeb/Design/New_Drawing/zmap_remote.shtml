<!--#set var="banner" value="ZMap - A New Display Design"-->
<!--#include virtual="/perl/header"-->

<!--#set var="author" value="edgrif@sanger.ac.uk" -->

<!-- some colours for our boxes etc. -->

<!-- lightpink = #FFB8C1 -->

<style>

pre{ background-color: #DDDDDD; border-style: solid; border-width: 1px; padding: 10px }

.code{ background-color: lightsteelblue }
.request{ border-color: red;  border-width: medium }
.reply{ border-color: green; border-width: medium }
.message{ border-color: blue; border-width: medium }

table.zmap_actions{ background-color: #EFEFEF; border-width: 1px; border-style: solid; border-collapse: collapse }
table.zmap_actions td{ border-width: 0px 1px 1px 0px; border-style: solid; padding: 2px }
table.zmap_actions tr{ vertical-align: top; }
table.zmap_actions th{ border-width: 0px 0px 1px 0px; border-style: solid; }

fieldset
{
background-color: lightblue;
border-style: solid; border-width: 3px; border-color: black;
padding: 10px
}

legend{ font-weight: bold }

</style>


<h1 align="center">ZMap - A New Display Design</h1>


<h2>Main Contents</h2>

<ul>
  <li><a href="#introduction"><b>Introduction</b></a></li>
  <li><a href="#perfect"><b>Perfect</b></a></li>
  <li><a href="#implementation"><b>Implementation</b></a></li>
</ul>


<a name="introduction"></a>
<h2>Introduction</h2>

<p>ZMap has been around for a number of years and while the underlying
software has always been foocanvas there have been a 3 major versions
to the way in which the foocanvas was used:</p>

<ul>
  <li><p>Originally each feature was decomposed into individual foocanvas items (e.g. boxes,
      lines or glyphs etc.) and then these individual items were drawn. This method had
      the advantage of simplicity and reasonable performance but led to some
      clumsy coding to group items into features, e.g. box/lines into a transcript for
      event handling, highlighting etc.</p></li>
  <li><p>A second effort subclassed existing foocanvas items to produce new zmapfoocanvas
      items that represented complex features such as transcripts. While this approach
      made the coding simpler it was disastrous for performance: alignments (by far the
      most numerous feature) were no longer represented by a single box but became a
      foocanavas group containing not just the box for the alignment but also boxes
      for under/overlays.</p></li>
  <li><p>A third effort concentrated on performance and removed all foocanvas items for
      features, foocanvas items representing columns were retained but nothing below
      that. This has terrific performance advantages but the disadvantage that now
      zmap code had to handle all drawing of graphics primitives, placement within
      columns, detecting mouse clicks on features and so on. And...of course this
      has complicated the code substantially...but the performance is much better.</p></li>
</ul>

<p>We have reached the stage where drawing in zmap once again needs attention, in particular
the following issues need to be addressed:</p>

<ul>
  <li><p><b>Performance - </b>we are not using the graphics potential of current hardware.</p></li>
  <li><p><b>Drawing Model - </b>Currently all viewable features are loaded in one go allowing rapid
      scrolling over that fixed range but we need to change to continuous loading of features allowing
      zmap to scroll over whole chromosomes.</p></li>
  <li><p><b>Vertical/Horizontal - </b>Acedb had vertical tracks which maximised the number of tracks
      that could be displayed but all other modern browsers show tracks horizontally which provides
      more sequence but fewer tracks.</p></li>
</ul>

<p>This document describes the issues, approach and effort required to reimplement zmap drawing.</p>


<a name="perfect"></a>
<h2>The Perfect Feature Display</h2>

<p>With repetition comes knowledge, or something like that. If we are to change
the zmap display then we should start with a list of features that the new code
must have in order to make the effort worthwhile.</p>


<h3>Track Orientation</h3>

<p>The new display needs a button that will toggle vertical/horizontal display
with minimal disturbance to the user (i.e. they should remain centered on the
position/track that was displayed before they changed orientation).</p>

<p>The importance of this cannot be overestimated, this is almost always the
main criticism of zmap: "ugh, why is it vertical".</p>


<h3>Multiple Windows</h3>

<p>One of ZMap's great selling points was the ability to split the feature view
an arbitrary number of times and to have different sequences in different
windows and to split those windows and so on. No browser-based or indeed java-based
stand alone program has replicated this and yet it's a great feature for the
annotators.<p>


<h3>Unlimited Scrolling</h3>

<p>It is now common to offer this but zmap does not and this needs to be addressed.</p>

<p>Zmap should be loading new features as the user scrolls and dumping those features
left behind by the scrolling.</p>



<h3>Zooming</h3>

<p>ZMap's zooming was always good but clunky once the maximum X Windows limit had
been reached because further scrolling was more and more limited in scope in order
to avoid exceeding the maximum window size.</p>

<p>Scrolling on demand would fix this by having a fixed window size.</p>

<p>Semantic zooming whereby the way in which features are displayed can change 
as the scale of the view changes. Particularly important if ZMap is to support 
annotation/curation of much larger sequence regions than currently handled.   </p>

<h3>User Configurability</h3>

<p>User adjustment of display features such as colour, bumping modes, track width, 
track ordering, histogram and graph ranges,
background colours, and many other things should be allowed. And also controllable 
to prevent such if necessary. As much of this as possible should be made dynamically 
controllable.</p>


<a name="perfect"></a>
<h2>Other Requirements</h2>

<h3>Platform Independence</h3>

<p>It is desirable to be able to do native builds on Linux, MacOS and Windows at least.
 Appropriate choices of libraries and toolkits at an early stage will bring this goal 
closer with no extra effort </p>

<h3>Future Proofing</h3>

<p>Poor choices of libraries and toolkits can lead to dependence not only on particular
operating systems but also on out-of-date and unmaintained (and indeed unmaintainable) 
tools such as the foocanvas. This must be avoided in order not to waste time in the future 
and make sure that we can take advantage of improvments in technology such as hardware 
acceleration.

<h3>Use of Standards</h3>

<p>Standards should be used where possible. This includes not only language standards such 
as the STL and boost but other efforts such as formal design methodologies (documented patterns) 
and drawing standards such as OpenGL.


<a name="implementation"></a>
<h2>Implementation Issues</h2>

<h3>Coordinate transforms</h3>

<p>ZMap was bedevilled by problems in this area, there was code all over the place
doing essentially the same things but differently. In defence of zmap the foocanvas
had a severe shortcoming: it could not deal with the situation where it's scrolled
window exceeded the X Window maximum of 32k pixels (or least 32k that you could draw
in to). This made going from feature space to window space <b>hard</b>.</p>


<h3>Model-View-Controller</h3>

<p>Whether you subscribe to MVC or MVP, ZMap's model became screwed up a long time
ago. This was largely the result of trying to accomodate rapidly changing requirements
without thinking things through more carefully. It has however made much of the code
harder to work on that it should have been.</p>

<p>On the face of it MVC/MVP should be relatively easy but in the case of zmap
there are requirements such as multiple windows on to the same sequence or
multiple windows onto different sequences that do it this area more complex.<p>

<p>Fortunately it is relatively simple (with approprite choices of libraries)
to ensure that the object model for the 
program as a whole and any display components can be kept separate from the drawing 
model itself. 


<h3>The Drawing Model</h3>

<p>There are several candidates for how drawing might work:</p>

<ul>
  <li>Simply draw feature data directly into a window, the only
      coordinate transform would be sequence/track coordinates to window
      coordinates. This has the advantage of simplicity but the disadvantage
      that drawing would need to be really fast to make scrolling possible.</li>
  <li>Draw features into buffers of some description from where the data would
      be moved into the window. Buffering would allow fetching data ahead and so
      avoiding delays but this would make the design significantly more complicated.</li>
  <li>Buffering of feature data. This does not refer to drawing buffers as such but 
      a subset of the overall set of features that are in or just outside of the 
      sequence/track area represented by the viewport. As the viewport is moved,
      features are added to the subset at one end, and removed from the other. Or 
      added/removed from both ends at the same time in the case of zooming.
  </li>
</ul>

<p>Other drawing issues to take account of:</p>

<ul>
  <li>We should use tools that allow us to take advantage of hardware acceleration 
      where possible.</li>
  <li>We must maintain separation of the widget set from the drawing code per se. 
       There are many widget sets that provide native drawing capabilities, but 
       these should be avoided in order to clearly deliniate the user interaction
       and display components and the drawing code itself. This will allow future 
       changes to one or the other to be done independently.</li>
</ul>



<h3>Choice of Libraries/Toolkits</h3>


<!--#include virtual="/perl/footer"-->
