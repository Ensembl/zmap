<!-- $Id: canvas_tweaks.html,v 1.2 2011-02-16 12:27:48 mh17 Exp $ -->

<h2>Speeding up the use of the Foo Canvas</h2>

<fieldset><legend>Basic Features made simple again</legend>
<h3>The problem: Basic features have been made complex</h3>
<p>
All ZMapWindowCanvasItems are currently FooCanvasGroups and contain lists of features for background, underlay, feature, and overlay and changing these to be simple FooCanvasItems may offer a significant performance improvement and simplify a lot of code and free up a lot of memory.  The initial display of ZMap is dominated by alignments (eg SwissProt and TrEMBL) which typically contain 90% of all features on display.
</p>
<h3>Caveats</h3>
<h4>Complexity is not used? </h4>
<p>Despite each basic feature consisting of several lists of canvas items these lists are empty and may not cause a significant delay.
</p>
<h4>Side effects</h4>
<p>When alignments get bumped their x-coordinate is changed and extra lines and glyphs are drawn on the canvas.  Use of the complex ZMapWindowCanvasItem structure may be necessary to do this.
</p>

<h3>Implementation</h3>
<h4>General comments about existing data and code</h4>
<p>
<ul>
<li> Currently all ZMap canvas items are constructed by inheriting foo_canvas_item (actually foo_canvas_group) and we have to preserve this as the item factory code works by creating a foo_canvas_item which is actually a derived object but refenced as a foo_canvas_item.
<li> We cannot use foo_canvas_items directly as we must also have a pointer to the relevant feature in the feature context.
<li>There are 25 instances in the source of ZMAP_IS_CANVAS_ITEM() which implies that we may be forced to have a base ZMapCanvasItem class with simple features and groups derived from it.  25 is not very many so modifying the code for this will be simple, and we can handle adding items  and groups as distinct class hierachies if necessary.
<li> the existing ZMapCanvasItem class is misnamed as it is really a canvas group, which is a shame as this means we have to edit 283 lines of code to use meaningful names.
<li> zmapWindowItemFactory.c contains functions to draw all types of ZMapCanvasItem and these all call zMapWindowCanvasItemAddInterval() which calls a class function to add a foo canvas item (or more) to the base class, so the interface is fairly modular and can be changed relatively easily.
</ul>
</p>
<h4>Canvas Item Class Structure</h4>
<p>Due to the technicalities of object instantiation in GLib it's not practical to derive groups and simple items from a single base class.  However as foo_canvas_group derives from foo_canvas_item they will all derive from foo_canvas_item so we do have a single base class at the bottom.  Note that we cannot have simple canvas items derived from foo_canvas_group and just not use the group data as the foo canvas code treats groups differently from items.
</p>
<p>
A simple canvas item (eg basic feature or ungapped alignment) will derive from a foo_canvas_item and have no additional lists of features.
<pre>
ZMapWindowCanvasItem    (contains ->feature, ->item_type)
    foo_canvas_item
</pre>
</p>

<p>
A complex canvas item (eg transcript, gapped alignment)  will derive from a foo_canvas_group (which derives from a foo_canvas_item) and will have a single list of subfeatures, rather than four as at present.  Note that this implies complex features may interleave on the display, but this is not thought to be an issue as transcripts are normally bumped as no overlap and alignments are only displayed complexly (eg with glyphs and colinear lines) when bumped.
<pre>
ZMapWindowCanvasGroup (contains ->feature, ->item_type, ->item_list)
  foo_canvas_group
    foo_canvas_item
</pre>
The item_list is a list of foo_canvas_items.
</p>

<p>The different types of ZMap canvas item (eg basic feature, transcript_feature) will derive from either ZMapWindowCanvasItem or zmapWindowCanvasGroup.  Note that alignments displayed as ungapped will be ZMapWindowCanvasItem and gapped as ZMapWindowCanvasGroup.
</p>

<h4>Container Classes</h4>
<p>These will derive from ZMapWindowContainerGroup as at present.  This derives from foo_canvas_group and contains a list of canvas items which in this case contains four foo_canvas_groups for the background, underlay, features, and overlay.  Some remarks in passing:
<ul>
<li> Mostly these groups in the items list will be empty and perhaps the code could be optimised by deriving from ZMapWindowCanvasGroup and using the item_type field.  There are access functions for each of these, so we could scan the short list and return NULL if not found.
<li> As all containers derive from ZMapWindowContainerGroup we can display all four levels of items for aligns, strand, blocks, featureset (column), but it's not clear what use this is. Some background rectangles do get drawn and soem are added to pick up mouse events, but ordering and handling of items in foo suggests that this could get very confused.
<li>ZMapWindowContainerFeatureset has seperate lists of:
<pre>
  GList *colinear_markers ;
  GList *incomplete_markers ;
  GList *splice_markers ;
</pre>
Are these needed?
<li> As we aim here just to make basic features into simple foo_canvas_items it would be unwise to alter any of this code.
</ul>
</p>

<h4>Operating the item factory</h4>
<p>Existing code adds canvas items by first creating a ZMapWindowCanvasItem (a foo_canvas_group) and then adding one or mor items to it via the class->add_interval function.  Necessarily for simple canvas items we will have to combine these two functions and the drawXXXFeature functions in zmapWindowItemfactory.c can be used to drive this with minimal effort.
</p>

</fieldset>

<a name="summarise"></a>
<fieldset><legend>Summarise Columns</legend>
<p>See also RT #177032, where this text orginated.</p>
<h3>Displaying invisible features slows ZMap down</h3>
<p>
Display time in ZMap is dominated by a few heavily populated columns eg Trembl may have 50k features but the majority of these features are obscured by others and cannot be seen. As operating the foo canvas takes 90% of the display time and a complete feature context can be scanned very quickly (eg 50ms to reverse complement all features, compared with 10sec to display) it may be possible to speed up this display by not adding invisible features to the canvas.  Note that due to the display format of alignments (centered rectangles) we can resonably expect to loose up to 98% of features off the display for a column like TrEMBL - if the column is 1000 pixels deep we cannot need to display more than 1000 features to give the same visual appearance.  There may still be some overlap caused by the simple scan algorithm.
</p>
<p>
This is a similar process to the idea of a summary display as to be provided by otterlace on request, but the difference is that ZMap would still have all the data and only real features will be used. The argument for having ZMap perform the necessary calculations is that ZMap knows when features become obscured at different zoom levels as it knows about pixel coordinates.
</p>
<p>
This process only applies to un-bumped columns and to implement this a column with an appropriate style parameter would be processed before display at the current zoom level.  This parameter defines the minimum zoom level at which to apply the summarising algorithm:
<pre>
[pep-align]
alignment-summarise=0.1
</pre>
</p>

<h4>Algorithm</h4>
<p>
<ul>
<li> sort the featureset into vertical order
<li> express features in canvas (pixel) coordinates (top, height, width)
<li> as features are displayed add their rectangles to a list in order of upper vertical coordinate
<li> if two rectangles next to each other have the same width combine them
<li> if a rectangle in the list is covered by the new/ combined one remove it
<li> if a rectangle covers the middle of a narrower one split the narrower rectangle into two
<li> rectangles may not overlap (strictly, including borders)
<li> when processing a feature if its width is &le; the min width of listed rectangles over the whole vertical distance do not display
<li> as features are processed remove rectangles from the list when they are out of range
</ul>

This uses little extra memory and comparisons are fairly quick as there is almost no searching involved.
Visibility is computed exactly and we can choose whether to display the items at the top or bottom of the foo canvas heap by sorting in reverse order.
</p>
<h4>Caveats</h4>
<p>
BumpCol would have to be changed to display the hidden features rather than moving thier x-coordinate. However bumping already includes adding lines and glyphs to the canvas and this should not be a significant problem.
</p>
<p>Functions such as 'List all Column Features' may have to be reviewed if they feed off the canvas data - perhaps some speed gains can be made by drawing features as hidden. (tests show about a 20-25% improvement by hiding all features.
</p>
<p> Displaying several featuresets in one column is more complicated especially when we consider that the summarise option is selected by a featureset's style.  It is possible so specify a style for a column abnd this perhaps provides some resolution despite allowing for mis-configuration.
However the intention was to speed up the display of featuresets like TrEmbl and SwissProt which normally appear in a column of thier own   It may not be worth implementing a comples way of combining featuresets like this, better to specify what happens if this is configured.  As a short term measure we will choose to summarise each featureset in a column independantly.
</p>
<h3>Implementation</h3>
<h4>Module and scope</h4>
<p>This will be a new module <b>zmapWindowContainerSummarise.c</b> and will operate on a ZMapWindowContainerFeatureSet, which may contain more than one featureset from the feature context.
</p>
<p>Note that in a view (which contains the feature context) if there are multiple windows open these are not constrained to be at the same zoom level (although you do have to unlock them first) and therefore it is not appropriate to maintain any flags in the feature context relating to this - all state information must be at the level of ZMapWindowCanvasItems.
</p>
<h4>Choosing featuresets and when</h4>
<p>Styles will be used to control whether or not to not display features.  This implies that it will be possible to select individual featuresets within a column for summarising.   Logically we could summarise columns other than alignments but as there are only two columns thought to be relevant (and they include only one featureset each) this will be phrased as an alignment mode option.  GF-splice glyphs look like another good candidate but as they are not rectangular features would require special code.
</p>
<p>We can also specify a minimum zoom level to do this at and avoid pointless computation.
</p>
<h4>Where to attach the filter</h4>
<p>We need to have access to canvas coordinates and this implies that we need to home in on the ItemFactory where these are calculated. In <b>zMapWinfowItemFactoryRunSingle()</b> a function  ((method)->method)() is called for each type of feature which creates and draws the ZMapWindowCanvasItem and when this is called the x and y coordinates have been calculated and adjusted for score if configured, but are in real world coordinates.  The foo canvas provides a function to convert called <b>foo_canvas_w2c()</b>.
</p>
<p>Filtering calls round this 'method. will allow us a single point of control and provides a clean interface to the rest of the code. There are futher offsets calculated later but as we need feature relative coordinates this is not relevant.
</p>
<h4>Data structures used</h4>
<p>We will use a simple linked list of reactangle structures and these will be freed at the earliest opportunity.  None of this has any permanence at all, although it will be held in the Window for use by callbacks.
</fieldset>
<fieldset><legend>Results</legend>
<p>After implementing the filtering algorithm as above we can see a big reduction in objects drawn and time used:
<table border="1" cellpadding="3" cellspacing="3">
<tbody><tr>
<th>FeatureSet</th><th>Features drawn</th><th>Total features</th> <th>Max list size<th>Time used</th><th>Previous Time </th><th>Time used</th>Ratio</tr>
<tr><td>TrEMBL</td> <td>722</td> <td>28922</td><td>4</td> <td>0.206sec</td> <td>4.865sec</td> <td>23.6</td></tr>
<tr><td>SwissProt</td> <td>554</td> <td>9563</td> <td>3</td><td>0.125sec</td> <td>1.606sec</td> <td>12.8</td></tr>
</tbody></table>
Given that the list of covered regions stays very short there seems little point in combining these as originally planned.  The reduction in time is a little dissappointing - it is related quite directly to the number of items drawn (1/40 for TrEMBL).  One deficiency is that the sorting of features is done using real coordinates and this may cause sorting by size (after start coordinate) to be ineffective and resolving this could result in significant further reductions.  However, trying this out gives no improvement, presumably due to the extra sorting overhead.
</p>
<h3>Some caveats</h3>
<p>This has so far been an experiment and there are some issues that need to be resolved:
<ul>
<li> some ZMap features such as list features in column may need to be adjusted to refernce the feature context rather than the canvas
<li> zoom appears to operate without doing a re-draw and this code needs to be adjusted to add featrues to the canvas
<li> bump column must draw the missing features
</ul>
The later two imply some performance overhead, although not as great as drawing the whole column in the first place.
</p>

</fieldset>

