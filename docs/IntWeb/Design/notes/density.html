<h2>Density plots</h2>

<fieldset><legend>Motivation</legend>
<h3> Summary data</h3>
<p>There are two main reasons for wanting to present a set of features in terms of volumes: 1) speed and 2) usefulness.
</p>
<p>
</p>Especially at low zoom levels high volume columns are displayed with many features overlapping with the result that most are not visible despite being drawn on the canvas.  Experiments with <a href="Design_notes/notes/canvas_tweaks.shtml#summarise">filtering out invisible features</a> from the display while still presenting the same picture show that improvements in speed by a factor of 20x are realistic.
</p>
<p>Features displayed in low resolutions are not very useful to annotators - the display at low zoom levels serves mainly to show where features are and a denisity plot would give more information - as mentioned above overlapping features are not visible and help no-one.  These kind of display have been requested specifically for <a href="Design_notes/notes/RNAseq.shtml">RNAseq</a> data.
</p>
<h3>GC content</h3>
<p>A related requirement is th show GC content which is a rolling average calculated from the DNA sequence and this can be displayed as a histogram or wiggle plot.
</p>

</fieldset>

<fieldset><legend>Display output</legend>
<p>Here we consider displaying any kind of feature entirely in terms of how many there are and there a few ways of representing this information.  We expect this process to be useful primarily for alignment features (eg Trembl, RNAseq)
</p>
<h3>Heat map</h3>
<p>Fixed width with each vertical pixel colour coded according to how many features overlap that region.</p>
<h3>Bar chart</h3>
<p>Horizontal stripes with the width corresponding to the number of features.
</p>
<h3>Wiggle plot</h3>
<p>A line chart (what most people think of as a graph)</p>
<img src="Design_notes/notes/density.png" class="img" alt="a picture of density plots">
<p>
Typically the density scale will be chosen as logarithmic.
</p>
<p>Other browsers (eg GBrowse - server side web based) implement density plots by using pre-computed bins based on different zoom levels but this imposes a requirement on the data source.  Figures such as "a few minutes for 16k features" have been mentioned for this pre-computation and this is not a good option for Zmap.
</p>
<p>Previous dicsussions have focussed on producing a summary display in ZMap before loading large datasets and this also implies pre-computation of bins of data but there are some difficulties with this approach:
<ul>
<li> unless the bins are computed off-line (and updated whenever the data set is updated) then this would imply a <i>reduction</i> in speed.  Using the pipeServer model of data transport data is requested from an external source, processed into GFF and output directly to ZMap and obviously can be passed through on the fly. To compute bins of data volumes to be sent to ZMap first would require the whole data set to be received by the pipeServer script before sending any of it the ZMap; effectively it would take twice as long to load.
<li> if bins are pre-computed then that requires the same extra function to be supported by many different data sources, or to be performed by the pipeServer interface scripts.  This introduces the possibility of faulty or non implemented function and also of unpredicatble delays (following database updates).
<li> any external source or script would have to work in terms of fixed size bins relating either to a fraction of the sequence range or a fixed number of bases, and would have to provide several levels of these.  These would not map onto the ZMap display directly and there woudl be a technical problem to solve in terms of mapping a sequence range onto display pixels.  Supplying the external script with ZMap display paramters is not practical as users are likely to resize the ZMap window and also to zoom to different levels.
</ul>
</p>
</fieldset>

<fieldset><legend>Implementing density plots in ZMap</legend>
<h3>Configuration - styles</h3>
<p>Whether or not to produce a density plot will be determined by a column's style using some new parameters.
A seperate style will be added for optional density mode displays and each normal features style will refer to this. It is also valid to define a featureset or column as a density plot regardless of the zoom level.
</p>
<p>Bumping the column will revert to using the normal style. The density style bump mode will be used to control whether or not this is allowed.
</p>
<p>A density mode style will automatically also be a graph mode style and graph-mode configuration will be used to drive the display. The difference between simple graph mode and density graph mode is that one used features and the other feature-frequencies per pixel.
</p>
<p>Note that a column style may be set independantly of the included featuresets or can be inferred by merging the  featureset styles.  All featuresets in a column will be treated as one for the purposes of density plots.
(for example if we created a UniProt column then Swissprot and Trembl would be displayed in different colours as at present when displayed at high zoom but would be combined to create a single density plot.
</p>
<p>Note that although most of the relevant data consists of alignments some high volume data (eg ensembl_variation) are basic features and therefore these parameters must apply to all style modes.
</p>

<pre>
[density-plot-trembl]
mode=density
graph-mode = heatmap | histogram | line  # default = heatmap
graph-scale = log | linear        # default = linear
colours = normal fill border # default = fill white; border black
# frame-colours are also possible according to frame mode

[trembl]
density-style = density-plot-trembl
</pre>
For a heatmap the colours used will be calculated according to the scale and between the fill and border colours, with border being the maximum density.
</p>
<p>
Existing style parameters will be used in a density mode style:
<pre>
width =  pixels
min-score = 0     # number of features for minimum score
max-score = 2000  # number of features for max score

max-mag = num-features
</pre>
Note that min-score and max-score define the number of steps in the display and also the behaviour of a heatmap - 0 will mean no features and displays as the fill colour and a single feature will be the next step up.
</p>

<h4>TDB:</h4>
<p>
<ul>
<li> go over <a href="Design_notes/notes/RNAseq.shtml">RNAseq</a> again and pay more attention to bumped and unbumped coverage displays.  What is the source data?
</ul></p>

<h3>Implementation - drawing the plots</h3>
<h4>Change of philosophy - virtual features</h4>
<p>Currently all displayed features are real and exist in the feature context. To preserve this significan design assumption it may be easiest to create a virtual column and create virtual features corresponding to the desity display at the current zoom level, where the bins for counting features correspond to vertical pixels.  Given a sorted list of features these can be calculated quite quickly.</p>
<p>
As the zoom level changes and we switch to the real data, we hide the virtual column ad display the real one.
</p>
<p> This process will be comapatable with denisty data provided externally that has biological significance eg Cage and DiTag data, where the tags are of necessity 20-40 bases long and cluster together.  Zmap can be provide with external features from a density featureset with a style set to match.
</p>

<h4>Implementation - drawing bins</h4>
<p>The simplest way to draw a density plot will be to draw one feature (rectangle, no border) per vertical pixel. For a heatmap these bins will appear to merge if they are the same colour. It may be possible to merge such features for real but it's not clear there would be any benefit.  For minimum zoom we are looking at about 1000 features maximum which is not a great performance overhead.
</p>

<h4>Implementation - triggering density plot or normal features</h4>
<p>Normally we would wish to display a density plot when the zoom level is such that features are not readily discernable due to overlap.  This is a) to give extra information and b) to implement a faster display.  Using the foo canvas we are limited to nominally 1000 pixels at minumum zoom and 30k pixels at maximum, but note that future developments may change this.  However we expect future technology to allow us to display significantly more features in less time.  We do wish to avoid drawing 30k density features - this would be missing the point of using these.  A solution would be to impose a maximum number of these in the style and increase the vertical size of the bins by whole numbers of pixesl as the xoom level increases.
</p>
<p>One way to decide when to switch between display modes would be the existing min and max zoom parameters in styles and this looks like a good place to start.  The disadvantage is that to achieve best results the style has to be set appropriately for the data and this is a trial &amp; error technique and will always be a compromise.
</p>
<p>Another way would be to set a minimum average or maximium bin volume - if no bins have more than X features then display the features.
</p>
<p>
What is important is that there is a clear switch between one style and the other.  For example if we defined styles to display at different zoom levels and display real features and density data in the same column there could be a transitional zoom level where both were displayed and we need to avoid this.
</p>
</fieldset>

<fieldset><legend>GC content</legend>
<h3>Not a density plot</h3>
<p>GC content provides an easy way to implement wiggle plots as a graph mode feature whcih can later be used  in a density plot environment subject to configuration.  Note that they are defined as style mode = graph!
</p>
<h3>Rolling window size</h3>
<p>A cursory scan of google suggests a window of 50-500bp - 50 as the GC skew can change suddenly and 500 relating to 'flanking DNA', with values being calculated at 100 bp steps (Human Molecular Genetics, 1999, Vol. 8, No. 6 1061?1067).  This suggests that we must provide this paramet in the style, and also possibly provide more than one graph, using different window sizes.  One way to implement this would be to define hard coded featuresets (like DNA) such as GC_Skew1, GC_Skew2 etc and map these into a single column (if desired) and attach different styles to specify the window size.
</p>
<p>If the zoom level is so low as to contain more bases than the window size per pixel then the GC content will be calculated per pixel. This will be triggered by setting min and max zoom levels per GC_Skew style (interpreted as base pairs per pixel), and a per pixel average will be triggered with a window size of 0.
GC Skew will not be displayed if the number of bases per pixel is greater than the window size, and the rooling window size will be set but the min_zoom style parameter.  The step size can also be parameterised; this will be useful for all density styles and provides a way to limit the munber of features displayed.
</p>

<h3>Graphical display</h3>
<p>A simple linear scale plot with 50% GC content as the centre and min and max_score in the style being used to define the extremes of the percentages to be displayed (eg 30 and 80%).
</p>
<p>
</p>
<h3>Efficiency</h3>
<h4>Sneaking past the FooCanvas</h4>
<p>Implementing a wiggle plot as a series of poly-line features may operate significantly faster in the foo canvas then a feature per line segment.  Implementing a single polyline may also operate slower due to having to redraw the whole feature every time.  If we work in a 30K pixel maximum window size and 100 lines per feature then this results in 300 features, which may paint quickly, and if so will allow us to paint rolling averages at maximum zoom.  These parameters can be held in a ZMap config stanza if necessary.  This may be significantly faster than histograms or heatmaps.  Implementing parameterised plots like this will also not tie us to any particular canvas.
</p>
<p>More realistically if we have (for example) a window size of 40 and a step size of 10 then a 30K pixel display will require 3000 line segments which could be configured are 100 features of 30 line segments.
If we have a sequence of 200k bp then the maximum number of line segments would be 2x20k ie 40k.
</p>

<h3>Showing details</h3>
<p> The window ruler can be modified to show details of the displayed averages at the current sequence coordinate if the mouse is over a GC column.
</p>


<h4>Redisplay on zoom?</h4>
<p>If we assume that we can display nominally 300 features of 100 line segments effciently using the Foo Canvas then we can just display the same features regardless of zoom level, but some features must be hidden or displayed depending on the zoom level, and hopefully this is already coded??
</p>
<p>By definition the per pixel average but be redisplayed on every zoom change.
</p>
<p>Long item handling must also be applied to these features.
</p>

<h4>Log and linear scales</h4>
<p>
If external data is supplies as logarithmic then the display style will have to be set to linear to avoid confusion we will set linear as the default and this confgiuration option can be omitted.
Log format displays will have to be calculated per bin and if the log() function is slow then we can calculate threshold values per horizontal pixel and look these up per bin.
</p>

<h3>Sample Configuration</h3>
<p> Here we illustrate GC Skew wiggle plots for low zoom and rolling average of 500 and 50 bp.  Note that the styles define whether of not we use wiggle plots or histograms etc and this is not hard coded.

<h4>ZMap Config</h4>

<pre>
[ZMap]
# number of lines per feature
wiggle_feature=100

[Columns]
# 3 hard coded featuresets, triggered by the prefix 'GC_Skew_'
# (styles default to the same name)
GC_Skew = GC_Skew_0; GC_Skew_500; GC_Skew_50
</pre>

<h4>Styles</h4>

<pre>
[GC_Skew]   # column style
width=20

[GC_Skew_0]
mode = graph         # not a density feature!
graph-mode = line
colours = normal border green
min-mag = 0         # per pixel average
max-mag=500         # don't display at bigger zoom, relates to GC_Skew_500

[GC_Skew_500]
mode = graph
graph-mode = line
colours = normal border blue
min-mag=500

[GC_Skew_50]
mode = graph
graph-mode = line
colours = normal border red
min-mag=50

</pre>

</p>

<h3>To Do</h3>
<p>
<ul>
<li>add style and configuration options
<li>generate rolling averages as configured for loaded DNA and store as features (in featuresets in the  feature context) with several values held in an array allocated off the heap.  Sort these into an ordered list.
<li>implement a new canvas item for wiggle plots
<li>check min/max zoom show/hide code and adjust as necessary
<li>add wiggle items to long items code.

</ul>
</p>

</fieldset>