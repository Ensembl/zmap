<h2>SQLite based configuration for ZMap</h2>


<p>As user requirements have grown to include 600+ BAM files (and 400+?? bigWig) and no doubt more in the near future the current flat .ini configuration system has become unworkable.
</p>

<p>There is a case for continuing to use the 'ZMap' config file for existing basic config but several parts of this system need to be handled differently and the obvious solution is an SQLite database.  Note that in the context of a ZMap session this data is entirely static; we explicitly choose to store any session state information elsewhere. Initially we will convert to SQLite large configuration data (style, featuresetsm columns, servers) and replicate the existing flat file information unchanged.
</p>

<p>This will also be an opportunity to tidy up some configuration options that have been added hurriedly over that past few years. It is also an opportunity to address the complications caused by using GQuarks as unique id's for data items - with SQL we can generate unique id's in the database and have names simply as names.
</p>

<p>There are two main use-cases: as part of the Otterlace annotation systema and as a standalone genome browser.  Otterlace can generate a database in whatever format is needed and our only concerns are that ZMap can read the data and Otterlace can generate it easily.  When acting as a standalone browser we need to ensure that users unskilled in SQL can use ZMap and make minor modifications to configuration, a few examples of this will be considered later.  It is imagined that a 'standalone users' includes those who have very simple configuration needs eg Ensembl style with only a few Core tracks.
This can be addressed by using an open source SQL browser or by providing a short Perl script to act as a very basic local webserver that handles HTML form submission.  Additionally several small Perl scripts can be provided to access and update records from the command line. (eg to re-order columns on the display, add a new data source etc etc.
</p>

<p>As the development of ZMap is likely to require many more configuration changes in the future we need to consider how this this will affect database structure. In terms of efficiency there are no real constraints as we are dealing with small amounts of data (for a database) and only accessing it as configuration (and storing this in memory for real-time use).
</p>

<h3>Configuring the configuration</h3>
<p>By default ZMap will attempt to read a database in the selected configuration directory (defaults to ~/.ZMap, or can be set via the arg --conf_dir=there) called 'ZMap_config.db'.   This file name can be set via another command line argument:
<pre>
zmap --conf_file=ZMap_my_stuff --conf_db=my_config.db
</pre>
or by a configuration option in the Zmap configuration file:
<pre>
[ZMap]
database = my_config.db
</pre>
Where files names are specified they are relative to the selected configuration unless they begin with '/'.
</p>


<h3>What data do we need to handle?</h3>

<h4>Styles</h4>

<p>387 defined in a recent-ish but out of date file
These work in a hierarchy and inherit attributes, if stored in SQL ths would be as a two simple tables that get processed by ZMap as at present from the ini stanza data - style inheritance will remain as a ZMap application function.
</p>
<pre>
style table
	style-id	unique key, indexed
	name

attibute table
	style-id	ref to style, indexed
	attribute-id	generic attribute: completely future proof
	value		text, converted to numeric by application code
</pre>

Note that styles have a large number of options some of which are mutually exclusive. Styles are referenced by featureset and columns; in existing flat file configuration this is by unique ID derived from the name, and we would be best converting this to a database unique ID.
</p>


<h4>Source data (featuresets)</h4>

<p>These map into columns on display and each one contains data of the same type.  Tradtionally the type of data was identified by the display style but this confuses presentation with the data model.  The type of data (eg transcript, alignment) implies the type and amount of information that can be attached to each feature and the relationships between parts, and there is a need to differentiate between some datasets operationally - BAM data is such high volume that we need to restrict access to small sequences only and do that on demand rather than on startup.
</p>
<p>With BAM data we expect approx 1000 of these to start with.</p>
<p>Featuresets have a display style and must be linked to a source/ server.
<p>

<h5>ACEDB legacy issues</h5>
<p>ACEDB supports request by column and supplies a mapping from featureset to column - it will be necessary to add this to the data extracted from SQL.  We'd like to avoid updating the SQLite database OTF, as then it would become state not configuration.
</p>


<h4>Servers</h4>
<p>These are the sources of feature data for ZMap and can be (currently) ACEDB, DAS (not fully implmented) pipe or file. Note that we do have DAS based data but this is accessed via a pipe script.  Each server can support one or more featuresets and has options such as load on startup.  As new source types (eg BAM, coverage) extra options become necessary, although most of these are best tied to the featuresets.
</p>


<h4>Display Configuration: columns</h4>
<p>Historically ZMap has operated  with a structure derived from ACEBD where columns of data (tracks) are requested and these may contain several featuresets.  Columns are ordered on the screen left to right in reverse and forward strands. Columns can be shown/ hidden and this implies operating on several featuresets in tandem.
</p>
<p>With BAM coverage data we need to map several featuresets into sub-columns - this has been achieved by inventing 'virtual featuresets' which map into coverage columns.  What is really needed here is nested grouping; the top level can be used to show/ hide several sub-columns and appears on the load-column dialog, and the intermediate level groups several featuresets into a display entity: two quite distinct functions.
</p>
<p>
</p>
<h5>Column ordering and other options</h5>
<p>Historically column order has been defined by a list of columns (as plain text) and while this works well for small numbers it has become unwieldy and also suffers from the (recent) existance of multiple lists and the fact that this single list of columns has multiple functions: display order, column request, grouping of featuresets.  These need to be teased apart into distinct configuration options.
</p>



<h3>Database tables</h3>
<p>As the database is regarded as static (write once, no updates) and only used for configuration there is little need for a higly optimised design and we opt for maximum flexibility.  Tables are defined as blank (named) records that have any number of related attibutes which are all defined in another table; attributes could in theory be shared between table types but it is probably clearer/ less confusing to define separate ones for each.  Where one table relates to another explicitly then we define a key in the table rather than using an attribute record to link them as this will make understanding and SQL syntax a bit easier.
</p>
<h4>A note abnout SQLite syntax and other foibles</h4>
<p>SQLite syntax differs from MyySQL and PostGres and this is summarised very well in <a href="http://www.sqlite.org/lang.html">this document</a>.
Each record has a unique rowid automatically - refer to <a href="http:/www.sqlite.org/autoinc.html">this</a> and <a href="http://www.sqlite.org/lang_createtable.html">that</a> for details.  Extra (+ composite) indices may be added if needed. Column data types are flexible and in the schema just give a general indication of what format the data takes.
We avoid the use of the automatic rowid as a primary key as it's not a standard SQL format, and declare primary keys explicitly.
</p>

<h4>Indexing policy and sample queries</h4>
<p>The main use by ZMap is to read in the whole database on startup and store in C data structures (and by Otterlace to write in bulk) and in that respect there is no need for any indexes.  However for manual changes (which are very likely with ZMap operating standalone) we need to ensure that queries can be processed efficiently and therefore include sensible indices as normal.
</p>
<p>Sample queries are provided to help future users and also to allow testing of the schema.
</p>

<h4>Recursive table structure</h4>
<p>To avoid much duplication of attributes we define most tables as being grouped or inheriting data from other of the same type.  This is something that SQL does not do but we define the relationship between two records in the same table and deal with inheritance in the application (C) code.  These records  (styles, servers and featuresets)  can be organised in a hierarchy (as that's the data we wish to model) but this is process outside of SQL - SQL just stores the information.
</p>

<h4>Sample table schema</h4>
<p> Here's a suggested schema, it's pre-implementation and may be subject to change.  Most of these queries have been tested but the exact syntax is not guaranteed - and example schema file will be created and circulated and should be used for real development; what's below is for discussion.
<pre>
-- sample database for ZMap config
-- use 'sqlite <db-name> ".read thisfile;"' to create the schema
-- we use rowid extensively to access tables, no need to specify explicitly
-- ref to http://www.sqlite.org/autoinc.html and also http://www.sqlite.org/lang_createtable.html


-- feature display style
CREATE TABLE zmap_style
(
	style_id INTEGER PRIMARY KEY,
	name TEXT,
-- styles inherit attributes from thier parents, recursively
-- parent_id is as in former style defintions
	parent_id INTEGER
);

CREATE INDEX idx_zmap_style_name ON zmap_style (style_name);

-- generic attributes of style
-- includes parent_style_id for nested style definitions
CREATE TABLE zmap_style_attribute
(
	style_id INTEGER,
	tag TEXT,
	value TEXT
);

CREATE INDEX idx_zmap_style_attribute ON zmap_style_attribute (style_id);


-- a (base) set of features of the same type
CREATE TABLE zmap_featureset
(
	featureset_id INTEGER PRIMARY KEY,
	name TEXT,
	style_id INTEGER,
	column_id INTEGER,	-- which column this appears in
					-- may be NULL if this is in a group
	server_id INTEGER,	-- where it comes from

-- featuresets can be grouped together, recursively
-- a group of featuresets is defined as another featureset record
	group_id INTEGER		-- the group that this featureset belongs to
);

CREATE INDEX idx_zmap_featureset_name ON zmap_featureset (featureset_name);
CREATE INDEX idx_zmap_featureset_column ON zmap_featureset (column_id);
CREATE INDEX idx_zmap_featureset_group ON zmap_featureset (group_id);


-- generic attributes of featureset
CREATE TABLE zmap_featureset_attribute
(
	featureset_id INTEGER,
	tag TEXT,
	value TEXT
);

CREATE INDEX idx_zmap_featureset_attribute ON zmap_featureset_attribute (featureset_id);



CREATE TABLE zmap_column
(
	column_id INTEGER PRIMARY KEY,
	name TEXT,
	style_id INTEGER		-- optional style for the column
);

CREATE INDEX idx_zmap_column_name ON zmap_featureset (column_name);


-- generic attributes of column
-- includes column order (position)
CREATE TABLE zmap_column_attribute
(
	column_id INTEGER,
	tag TEXT,
	value TEXT
);

CREATE INDEX idx_zmap_column_attribute ON zmap_column_attribute (column_id);


-- server - provides features from one or more featuresets
CREATE TABLE zmap_server
(
	server_id INTEGER PRIMARY KEY,
	name TEXT,
-- servers can inherit attibute from others, recursively
-- eg pipe_DAS for generic DAS options, pipe_ENCODE for BAM servers from ENCODE
	server_type_id INTEGER
);

CREATE INDEX idx_zmap_server_name ON zmap_server (name);

-- generic attributes of server
CREATE TABLE zmap_server_attribute
(
	server_id INTEGER,
	tag TEXT,
	value TEXT
);

CREATE INDEX idx_zmap_server_attribute ON zmap_server_attribute (server_id);

</pre>
</p>


<h5>Table attribute options</h5>
<p>There is a need for quite a lot of these and also a need to be able to add more on an ad-hoc basis. These will be doucumented by adding attribute records with a related table id (eg feautreset_id, style_id etc) of 0 and the value set to some descriptive text.  These can then be listed quite easily via a simple SQL query.
<pre>
select tag as attribute, value as description from zmap_style_attribute where style_id = 0;
</pre>
</p>
<p>Note that attributes are not uniquely specified per parent table, and where the original .ini file configuration has lists of data these will be added as separate attribute records with the same tag.
</p>


<h4>Setting column ordering</h4>
<p>A fiedl in the columns record will be use to store a colum's display position. In case of mis-configuration (ie two columns with the same position) ZMap will carry on regardless - the ordering of the misconfigured columns will be stable relative to the others .  There is a feature request active to drag and drop columns when live, but this table defines the default which is explicitly defined centrally on request from Havana.
</p>
<p0>
Queries like the following may be used to move columns around, eg to insert a column after the 5th from the left:
(NOTE that although the value field is defined a TEXT SQLite will still do arithmetic on it).
<pre>
update zmap_column_attribute set value=value+1 where tag = "position" and value >= 6;
insert into zmap_column_attribute (column_id, tag. value values(123, "position", 6);
</pre>
</p>
<h5>Column Ordering and Tabs</h5>
<p>Columns are defined as appearing on different Tabs on the load columns dialog and are grouped with other similar columns.  Order is defined relative to each Tab: these are defined from several different data sources (eg otterlace, encode) and these tabs are optional depending on the desired configuration.  It is believed that each tab contains data of significanlty different types and there is no requirement to mix these.
</p>
<p>Groups of columns are nominally displayed together but it is possible to have a group of columns in the load columns dialog that are disjunct on the display.  Many columns are optional depending on species and these are defined for all species/ datasets which implies that the column ordering within each Tab will be stable.
</p>


<h4>Some example queries (converting existing config files to SQL)</h4>
<p>Thanks to James Gilbert for these... (Note some of the field names differ from the above, it's an earlier iteration.
<p>
<pre>
-- Example adding this ini style file data into the schema:
--
-- [EST_align]
-- colours=normal fill Purple ; normal border #3d1954
-- parent-style=dna_align
-- alignment-mask-sets=self ; vertebrate_mRNA

INSERT INTO zmap_style (style_name) VALUES ('EST_Align');
SELECT style_id FROM zmap_style WHERE style_name = 'EST_Align';

-- Assuming SELECT returns '102', then:

INSERT INTO zmap_style_attribute (style_id, style_tag, style_value) VALUES ('102', 'colour', 'normal fill Purple');
INSERT INTO zmap_style_attribute (style_id, style_tag, style_value) VALUES ('102', 'colour', 'normal border #3d1954');
INSERT INTO zmap_style_attribute (style_id, style_tag, style_value) VALUES ('102', 'parent-style', 'dna_align');
INSERT INTO zmap_style_attribute (style_id, style_tag, style_value) VALUES ('102', 'alignment-mask-set', 'self');
INSERT INTO zmap_style_attribute (style_id, style_tag, style_value) VALUES ('102', 'alignment-mask-set', 'vertebrate_mRNA');

-- Example query to fetch info for EST_Align style:
SELECT fa.style_tag
  , fa.style_value
FROM zmap_style f
  , zmap_style_attribute fa
WHERE f.style_id = fa.style_id
  AND f.style_name = 'EST_Align';

-- Example query to fetch info for EST_Mouse style:
SELECT fa.featureset_tag
  , fa.featureset_value
FROM zmap_featureset f
  , zmap_featureset_attribute fa
WHERE f.featureset_id = fa.featureset_id
  AND f.featureset_name = 'EST_Mouse';
</pre>
</p>

<h3>End user configuration</h3>
<p>Here we assume a user has no knowledge of SQL and we wish to ensure that reasonable configuration changes can be effected.</p>
<h4>Re-ordering columns</h4>
<p>This requires two seperate SQL queries and clearly needs a trivial script. Columns are ordered via a series of records and to move one it has to be deleted and inserted in the sequence, which involves updating many records.
<h4>Adjusting a style</h4>
<p>Styles have many attributes and these can be presented on a generic SQL browser style form.  Note that due to style modes some options will be meaningless and we need to prevent misuse.
</p>
<h4>Adding BAM sources and combining these into a column</h4>
<p>This is quite complex.  The user must define URLs and query options (assuming we provide generic scripts to drive the request process).  Featuresets provided must be defined and linked to styles, which may need to be created. Columns must be defined and featuresets grouped and mapped into them.  Columns must be placed on the load columns dialog in the appropriate tab and group.
</p>
<p>Clearly this requires extensive user documentation, and as much scripted help as we can provide.  This looks optimistic for a naive user.
</p>


<h3>Driving the Load Columns dialog</h3>
<p>One of the uses of database driven configuration is to facilitate implementation of a tidier Load Columns dialog. In this, columns that may be requested are grouped into Tabs (eg Code, RNAseq, etc) and within each tab they are grouped further (eg Transcripts,EST's etc).  This will be very easy to implement using two attributes connected to each column.
</p>
<p>Another requirement is to handle columns that may not be requested directly or only be requested from the marked region, and this is a clear case for more attributes.
</p>



