<!--#set var="banner" value="Coding Notes"-->
<!--#set var="stylesheet" value="css/zmap-default.css" -->
<!--#set var="author" value="edgrif@sanger.ac.uk" -->

<!--#include virtual="/perl/header"-->


<style>
pre{ width: 95%; background-color: #DDDDDD; border-style: solid; border-width: 1px; padding: 10px }
.example{ border-color: #000000 }
</style>





<p>No one coding style suits all, no one coding style is perfect. However,
the style for the zmap project is described here and you must stick to this style
so that we can all read each others code simply, easily and quickly.</p>


<h2>Contents</h2>


<p><a href="#header_file_layout">Indentation</a></p>
<p><a href="#code_file_layout">Indentation</a></p>
<p><a href="#indenting">Indentation</a></p>
<p><a href="#commenting">Commenting</a></p>
<p><a href="#naming">Type, Function and variable naming</a></p>
<p><a href="#return_values">Function return values</a></p>




<a name="header_file_layout"></a>
<h2>Header file layout</h2>

<p>The standard layout for header files is:</p>


<pre><code>/*  File: FILE NAME
 *  Author: YOUR NAME (YOUR EMAIL ADDRESS)
 *  Copyright (c) 2006-2013: Genome Research Ltd.
 *-------------------------------------------------------------------
 * ZMap is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * or see the on-line version at http://www.gnu.org/copyleft/gpl.txt
 *-------------------------------------------------------------------
 * CREDITS
 *
 * Description: 
 *
 *-------------------------------------------------------------------
 */
#ifndef UNIQUE_DEF_SYMBOL
#define UNIQUE_DEF_SYMBOL

other #includes

macros

typedefs

function prototypes

#endif /* !UNIQUE_DEF_SYMBOL */
</code></pre>

<p>An abbreviated example for zmap code:</p>

<pre><code>/*  File: zmapGFF.h
 *  Author: Ed Griffiths (edgrif@sanger.ac.uk)
 *  Copyright (c) 2006-2012: Genome Research Ltd.
 *-------------------------------------------------------------------
 * ZMap is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * or see the on-line version at http://www.gnu.org/copyleft/gpl.txt
 *-------------------------------------------------------------------
 * This file is part of the ZMap genome database package
 * originated by
 * 	Ed Griffiths (Sanger Institute, UK) edgrif@sanger.ac.uk,
 *        Roy Storey (Sanger Institute, UK) rds@sanger.ac.uk,
 *   Malcolm Hinsley (Sanger Institute, UK) mh17@sanger.ac.uk
 *
 * Description: Interface to a GFF parser, the parser works in a
 *              "line at a time" way, the caller must pass complete
 *              GFF lines to the parser which then builds up arrays
 *              of ZMapFeatureStruct's, one for each GFF source.
 *
 *-------------------------------------------------------------------
 */
#ifndef ZMAP_GFF_H
#define ZMAP_GFF_H

#include <glib.h>

#include <ZMap/zmapFeature.h>


/* An instance of a parser. */
typedef struct ZMapGFFParserStruct_ *ZMapGFFParser ;


/* Feature clip mode, selects how individual feature coords should be clipped in relation
 * to the requested feature range (the gff file may contain features that are outside the
 * requested range. */
typedef enum
  {
    GFF_CLIP_NONE,					    /* Don't clip feature coords at all. */
    GFF_CLIP_OVERLAP,					    /* Exclude features outside the range,
							       clip anything that overlaps (default). */
    GFF_CLIP_ALL					    /* Exclude features outside or
							       overlapping. */
  } ZMapGFFClipMode ;



ZMapGFFParser zMapGFFCreateParser(char *sequence, int features_start, int features_end) ;
gboolean zMapGFFParserInitForFeatures(ZMapGFFParser parser, GHashTable *sources, gboolean parse_only) ;


#endif /* ZMAP_GFF_H */
</code></pre>



<a name="code_file_layout"></a>
<h2>Code file layout</h2>










<a name="indenting"></a>
<h2>Indentation</h2>



<P>The standard for code has been to indent by two for each block, there seems
no reason to change it. Line length should be kept to somewhere between 80 up to
a maximum of 120 chars, i.e. something that will fit comfortably on to a screen with a reasonable
font size. Do not exceed lines of length 120 chars.</p>


<p>Here is the standard indentation for a function:</p>

<pre><code>int func(void)
{
  int some_var ;

  if (blah)
    {
      call_something() ;
    }


  switch (dialog_type)
    {
    case ZMAP_DIALOG_SHOW:
      dialog_text = "Show" ;
      break ;
    case ZMAP_DIALOG_EXPORT:
      dialog_text = "Export" ;
      break ;
    default:
      zMapAssertNotReached() ;
      break ;
    }


  while (window_array->len)
    {
      stuff....
    }


  do
    {
      stuff......
    }
  while((list = g_list_next(list)));


  return ;
}
</code></pre>




<P>A good way to maintain consistency is have the editor do the indenting/commenting
etc. If you use the right profile code then there are some emacs functions
to do this which include:</p>

<ul>
  <li><b>Alt-X indent-region</b> will indent the code for the marked region.
  <li><b>TAB</b> indents the current line (or moves the cursor to the correct
      indentation on a blank line.
</ul>




<a name="commenting"></a>
<h2>Commenting</h2>

<P>Block comments and line comments should be in this style:</P>

<pre><code>
  if (blah)
    {
      /* This is quite a long block
       * comment that runs to more than one
       * line. */
      call_something() ;				    /* Starts at col. 60 */
    }
</code></pre>

<P><b>All</b> functions should be directly preceded by a block comment that
describes what the function does:</P>


<pre><code>/* This function does absolutely nothing. */
int func(void)
{



  return ;
}
</code></pre>


<a name="naming"></a>
<h2>Type, Function and variable naming</h2>

<h4>General naming conventions:</h4>


<ul>
  <li><b>Types:</b> ThisIsATypeName
  <li><b>Functions:</b> thisIsAFunctionName
  <li><b>Variables:</b> this_is_a_variable_name
</ul>


<h4>Function names</h4>

<P>Its useful to adopt different naming styles for external interface functions, internal interface
functions and static functions:</p>


<ul>
  <li><b>External interface functions</b> have external linkage, are declared in <b>public</b>
      headers and should be named:
      <ul>
	<li><b>zMapXXXXX</b>
      </ul>
  <li><b>Internal interface functions</b> have external linkage, are declared in <b>private</b>
      headers and should be named:
      <ul>
	<li><b>zmapXXXXX</b>
      </ul>
  <li><b>static functions</b> have internal linkage only, are declared within the file
      where they are defined and should be named:
      <ul>
	<li><b>anythingYouLike</b>
      </ul>
</ul>


<a name="return_values"></a>
<h2>Function return values</h2>

<P>By convention the first variable declared in a function should be the return value
which should <b>ALWAYS</b> be correctly initialised:</p>

<pre><code>gboolean someFunc(void)
{
  gboolean result = FALSE ;

  return result ;
}
</code></pre>


<p>This helps a lot with scanning the code and ensures that the return variable will be
sensible even if the code is changed..</p>

<p>Try to avoid multiple return statements in a function:</p>

<pre><code>Write functions like this:

gboolean someFunc(gboolean do_something)
{
  gboolean result = FALSE ;

  if (do_something)
    {
      if (some_factor)
        result = TRUE ;
    }

  return result ;
}

rather than this:

gboolean someFunc(gboolean do_something)
{
  if (!do_something)
    return FALSE ;

  if (some_factor)
    return TRUE ;
  else
    return FALSE ;
}
</code></pre>










<h3>Error handling vs. use of zMapAssert()</h3>

<p>A standard way to test that program state is as you expect while debugging
is via the assert macro or variants thereof. One problem with this kind of
macro however is that it easily gets used where really the code should detect
the error and handle it via a return code, user message or whatever.</p>


<p>The following guidelines should be followed:</p>

<ul>
  <li><p><b>"Package" interface functions:</b> must handle errors in the supplied
      parameters and return error codes when given faulty data.</p>
  <li><p><b>"Package" internal functions:</b> should use the zMapAssert() macro
      to test essential inputs and core dump if there are errors.</p>
</ul>

<p>The philosophy is that packages should "expect" and handle errors in their
inputs while functions internal to packages should expect no errors in their
essential inputs and should abort when this happens as it indicates a programming error
within the package.</p>


<p>Currently ZMap code has not adherred to this philosopy rigidly enough with
the result that ZMap crashes in places where it should be handling errors 
and ultimately logging an error and/or displaying an error to the user.</p>



<!--#include virtual="/perl/footer"-->

