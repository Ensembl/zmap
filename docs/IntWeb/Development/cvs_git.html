<h2>Version Control</h2>
<p>I'm still working on this, it's a bit ragged at the end especially. I'll have to run through all the commands and cut and paste real examples...
</p>

<fieldset><legend>Version control for ZMap</legend>

<p>Historically ZMap has used CVS to store source code documentation and scripts and prior to constructing version 1.0.0 of ZMap it is intended to switch to using git.  There are a subset of CVS commands used by the ZMap team plus a few custon scripts and we envisage a similar situation with git - the intention is to keep things as simple as possible. There are two main sections to this page: a) <a href="Design_notes/build/cvs_git.shtml#convert">converting to git</a> and b) <a href="Design_notes/build/cvs_git.shtml#usegit">Using git</a>.
</p>

<h3>Documentation provided (git)</h3>
<p>Quite a lot of readable docs are available online:
<ul>
<li> <a href="http://git-scm.com/documentation"> git front page</a>
<li> <a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html"> tutorial/easy introduction</a>
<li> <a href="http://www.kernel.org/pub/software/scm/git/docs/gitcvs-migration.html"> importing from CVS</a>
</ul>
The reader is advised to refer to these and others on the git web site as well as this document.
</p>
Command line help is also quite user friendly:
'git ?help' brings up a list of commands (like CVS) and individual commands produce a Unix man-page. You can also access these with (eg) 'man git-merge' like commands for various git features.

</fieldset>


<a name="convert"></a>
<fieldset><legend>Converting ZMap CVS to git</legend>
<h3>Orientation</h3>
<p>
In the interests of simplicity we aim to keep the last CVS version as a backup and simply import all the files tags and commit history using the tools provided by git with default paramters.  We see little benefit in detailed older versions as there are no legacy user issues of relevance.
</p>
<p>
</p>Other groups have imported CVS histories in great deatil but this is reputedly a tricky and time consuming process (eg <a href="http://lwn.net/Articles/409635/">PostgresSQL</a>).

<h3>Importing from CVS</h3>
<p>Creating a repository from an existing CVS checkout is trivial.  Importing change history is thought to be relatively simple and requires a program called cvsps, which is available in /usr/bin on the deskpros.  This program detects 'patchsets' consisting of commits of multiple files.  Various people suggest that the import process is imperfect and that CVS commits are not grouped together appropriately in all cases.
</p>
<p> As we intend to save the last CVS as a backup then we can work with a flat import with all files apparently created at the same time.  Previous versions can be checked out from CVS if needed.  Indeed, git allows the developer to re-invent history by re-basing a repository on another version and this implies that it will be possible to checkout an old version from CVS, import it into git and rebase the original to that, which then implies that a modification to the old version can be merged into the current. <b>NOTE</b>: this circumstance is thought to be very unlikely and possibly complex, It will be much more practical to import the ZMap tags and restrict the use of old versions to offcial builds.
</p>
<p>
An experiment reveals that importing the ZMap CVS take about 30 minutes, and this imports all the tags and commit history, and has master and origin branches. This is in ~zmap/git and uses 43MB of disc space, compared with 69MB for a ZMap source tree with object files. Git can be told to ignore certain files (eg *.o).
This could work as a master copy similar to the existing CVS repository.  The documentation states that this import is incremental  and changes in the existing CVS can be added to the repository, which implies that it is possible to switch from CVS to Git with no risk ? they can be run in parallel (although there's no mention of exporting back to CVS).
</p>

<h3>Hosting the git repository</h3>
<p>Our use of  CVS is to provide a master copy of the source with individual checkouts being made by developers that are uploaded to the master copy when tasks are completed.  For distribution we make a tarball of the source - there is no public access to the repository.
</p>
<p>To emulate this with git the following is proposed:
<ul>
<li> a master repository, say zmap.git, will be stored in git.internal.sanger.ac.uk:/repos/git/annotools/
<li> git clones will be made by developers and these may include branches (or multiple clones created)
<li> after completing development the developer will push thier updates to the master clone
<li> official builds will only be created from the master copy in ~zmap/git.  Note that this is not the distributed model espoused by git but instead the 'person-independant' philosophy practiced by the Zmap team.  It also imples that the master copy only contains stable tested code
<li> distribution tarballs are made by 'offcial' builds from ~zmap/git
</ul>
Note that due to file permissioning issues developers need to be in a 'zmapteam' group to upload their work. An alternative way would be for them to log in as zmap and pull their updates for thier clones instead of pushing them.
</p>
<p>
Note that repositories in this location will be available on gitweb (<code>http://git.internal.sanger.ac.uk</code>) unless you remove world-read permission.
</p>

<h3>Simple differences between CVS and git</h3>
<p>Note should be take of the following:
<ul>
<li> unlike CVS git does not add a version/timestanp in the files themsleves (in CVS via $Id: cvs_git.html,v 1.2 2011-02-08 13:10:42 gb10 Exp $), which is arguably better in that the version control is externs the what is being controlled - CVS cannot do this for binary files for instance.
<li> CVS has been set up to checkout files as read only and to require files to be explicitly opened for editing whereas git records file permissions and therefore emulating this kind of behaviour is not ideal. Instead git is aware of changes to files and only those changes that have been explictly added will be committed to the repository (you have to add chenges in content rather than files) - so git provides a similar kind of control but allows instant editing.  Use git-show to see what files have been changed or added.
</ul>
</p>


</fieldset>

<a name="usegit"></a>
<fieldset><legend>Patterns of use in the ZMap development environment</legend>
<p>
git is very powerful and has far more features than are needed by the ZMap team and here we define the subset of git features that we intend to use and a number of expected tasks.  Note that our use of git is entirely local - there are no public repositories and no use of emailed updates.
</p>
<p><b>NOTE</b> that what appears below is a quick summary and users should refer to the git man-pages, which are very informative and have examples.
</p>

<h3>Import a CVS tree into git</h3>
<p>Since inception the Zmap source tree has not been branched in CVS and this makes the import process much simpler.  Simply run these commands with CVS configured as normal:
<pre>
cd ~zmap/git
git cvsimport -a -v ZMap
</pre>
This takes about 30 minutes, after which the ~/zmap/git directory contains a copy of the CVS source tree/
</p>

<h3>Create a bare repository</h3>
<p>The master repository should be a bare repository; that is, a repository that just contains the .git directory but not the checked-out working tree.  This is because if you push to a repository that has a checked-out working tree, the working tree will not be updated by the push.  This may lead to unexpected results if the branch you push to is the currently checked-out branch.
</p>
<p>We can create a bare repository from any existing repository, e.g. from ~zmap/git.  Create the master repository as the zmap user to make sure the owner and group are correct.
<pre>
cd /repos/git/annotools
mkdir zmap.git
cd zmap.git
git --bare init --shared
git --bare fetch ~zmap/git master:master
</pre>
</p>
The --shared option makes the repository group-writable.
</p>
<p>
Edit the <code>description</code> file in <code>zmap.git</code> to set the description that will be visible on gitweb.
</p>

<h3>Setting up access permissions</h3>
<p>We have set the master repository to be group-writable with the --shared option in the above section.  We need to make sure the owner of the repository is the zmap group, which will already be the case if we created the master repository as the zmap user (if not, then we can change the group with chown or chgrp, but this will overwrite the 's' in the group permissions, so we would need to put that back).  We should also run the following 'setfacl' commands to ensure that all file permissions are inherited when new files are created.
<pre>
export GIT_DIR=/repos/git/annotools/zmap.git
setfacl -d -m g::rwx $GIT_DIR/{refs,objects,branches}
setfacl -m g::rwx $GIT_DIR/{refs,objects,branches}
setfacl -m g::rw $GIT_DIR/HEAD
</pre>
</p>
<p>Our repository contents should now look something like this:
<pre>
drwxrwsr-x+ 2 zmap zmap    6 2010-11-30 09:52 branches
-rw-rw-r--  1 zmap zmap  126 2010-11-30 09:52 config
-rw-rw-r--  1 zmap zmap   58 2010-11-30 09:52 description
-rw-r--r--  1 zmap zmap 1066 2010-11-30 09:52 FETCH_HEAD
-rw-rw-r--  1 zmap zmap   23 2010-11-30 09:52 HEAD
drwxrwsr-x  2 zmap zmap 4096 2010-11-30 09:52 hooks
drwxrwsr-x  2 zmap zmap   20 2010-11-30 09:52 info
drwxrwsr-x+ 4 zmap zmap   28 2010-11-30 09:52 objects
drwxrwsr-x+ 4 zmap zmap   29 2010-11-30 09:52 refs
</pre>
<p>

<h3>Registering with git</h3>
<p>To make normal commands easier it is recommended to define users and shortcuts:
Each user should register their name and email address so that this information can be recorded against commits, e.g. with:
<pre>
deskpro1[fred]5: git config --global user.name "fred"
deskpro1[fred]6: git config --global user.email fred@sanger.ac.uk
</pre>
If you cloned a repository, then by default you will already have the 'origin' alias set up to point to the repository that you cloned.  Use 'git remote -v' to view existing aliases.  You can also explicitly set up an alias to a specific repository as follows:
<pre>
deskpro1[fred]16: git remote zmap ~zmap/git
</pre>
</p>

<h3>Other useful configuration</h3>
<p>Git can <a href= http://progit.org/book/ch7-1.html#colors_in_git>color its output</a>.  To turn on default terminal coloring use:
<pre>
git config --global color.ui true
</pre>
</p>
<p>You can create your own formatted/colored output from the log command using the --pretty option.  The following gives an example.  You can use --pretty with 'git log' directly, but here I've set up alias commands, 'lg' and 'tg', to show a nicely formatted log and tag list respectively (works best on a black background!).  You could also set the 'format.pretty' config item to change the default format for the log command.
<pre>
git config --global alias.lg "log --graph --pretty='format:%Cgreen%ai%Creset - %Cred%h%Creset %C(yellow)%d%Creset %s %C(cyan)<%an>%Creset %Cgreen(%ar)%Creset'"
git config --global alias.tg "log --tags --simplify-by-decoration --pretty='format:%Cgreen%ai%Creset %C(yellow)%d%Creset'"
</pre>
<pre>
mac18480i[gb10]16: git tg
<font color="green">2010-12-07 18:25:55 +0000</font>  <font color="yellow">(BUILD-2010_12_07)</font>
<font color="green">2010-12-06 16:07:47 +0000</font>  <font color="yellow">(BUILD-2010_12_06)</font>
<font color="green">2010-11-30 16:20:39 +0000</font>  <font color="yellow">(new-build-system, dev)</font>
<font color="green">2010-10-19 09:52:54 +0000</font>  <font color="yellow">(RELEASE-4_9_54)</font>
<font color="green">2010-10-18 14:06:53 +0000</font>  <font color="yellow">(test-release-pre-new-dotter)</font>
<font color="green">2010-06-11 09:38:31 +0000</font>  <font color="yellow">(RELEASE-4_9_53)</font>
<font color="green">2010-05-06 09:36:42 +0000</font>  <font color="yellow">(RELEASE-4_9_52)</font>
<font color="green">2010-05-05 15:17:24 +0000</font>  <font color="yellow">(RELEASE-4_9_51)</font>
<font color="green">2010-04-21 17:23:03 +0000</font>  <font color="yellow">(RELEASE-4_9_50)</font>
<font color="green">2010-03-26 15:17:20 +0000</font>  <font color="yellow">(RELEASE-4_9_49)</font>
<font color="green">2010-02-26 16:37:06 +0000</font>  <font color="yellow">(RELEASE-4_9_48)</font>
<font color="green">2009-11-03 18:28:23 +0000</font> 
</pre>
</p>
<p>You can specify a tool to view diffs with by using 'git difftool' rather than 'git diff'.  To set the default tool used by difftool to, say, diffuse, use:
<pre>
git config --global diff.tool diffuse
</pre>
</p>

<h3>Setting up repository options</h3>
<p>As git allows you to perform operations on all files that have been modified, there is value in having it ignore certain files, e.g. object and temporary files.  This is done by specifying file names or patterns in a file called '.gitignore' (generally placed in the top level directory of the project), or in .git/info/exclude.  Generally, .git/info/exclude is used for things that are applicable to your local repository only.  A .gitignore file can be checked in as part of the project, so it can be used for anything that is also useful to other developers on the project.
</p>
<p>For example, the .gitignore file might contain:
<pre>
*.[oa]
*~
.DS_Store
</pre>
</p>
<p>and my local .git/info/exclude file might contain:
<pre>
my_notes.txt
mylog/*
</pre>
</p>

<h3>Clone a repository</h3>
<p>Developers should not work on the master respository but instead make a clone of it.
<pre>
mac18480i[gb10]253: mkdir git
mac18480i[gb10]254: cd git/
mac18480i[gb10]255: git clone git.internal.sanger.ac.uk:/repos/git/annotools/seqtools.git
Cloning into seqtools...
remote: Counting objects: 2532, done.
remote: Compressing objects: 100% (463/463), done.
remote: Total 2532 (delta 2064), reused 2532 (delta 2064)
Receiving objects: 100% (2532/2532), 1.53 MiB, done.
Resolving deltas: 100% (2064/2064), done.
mac18480i[gb10]256: cd seqtools/
mac18480i[gb10]257: ls -a
.		..		.git		.gitignore	src
</pre>
After this files may be edited as normal, programs compiled and tested.
</p>


<h3>Editing files</h3>
<p>Edit the files as normal. When finished use:
<pre>
git add [files]
</pre>
to queue the changes for commit.  Modified files that have not been added using 'git add' will not be committed by default, but you can use the -a option to commit all files that have been modified or deleted.  New files must always be added with 'git add' before they will be tracked.
<pre>
git commit -a
</pre>
</p>

<h3>Showing git/ file status</h3>
<p>The command:
<pre>
git status
</pre>
lists all modified files and all changes addded for commit.
<pre>
git show
git diff
</pre>
Reveal the differences between current and indexed files.

<h3>Committing files</h3>
<p>
'git commit' will commit all files staged with 'git add' or specific files may be specified. The flag -a tells git to commit all files that have been changed, which includes deletions (but not additions).
<pre>
git commit -a -m "this is my new wizzo feature"
</pre>
<pre>
git add zmapWorking.c
git commit -m "a small bug fix" zmapWorking.c
</pre>
</p>

<h3>Resolving Conflicts</h3>
<p>Unlike CVS, a commit is to the current local clone and there can be no editing conflicts arising (this assumes that each developer clones the master).  Likewise different branches from a single clone have conflict free histories.   Conflicts can occur on merging branches or pulling fields from another repository (pull does a fetch and merge).
</p>
<p>As for CVS, conflicts are indicated with marker lines such as:
<pre>
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt
Conflict resolution is hard;
let´s go shopping.
=======
Git makes conflict resolution easy.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
</pre>
Please refer to 'man git-merge' or <a href="Design_notes/build/cvs_git.shtml#branches">operating branches</a> below for the merge process.
</p>

<h3>Adding and Deleting files</h3>
<p>
Create or delete the files using normal linux commands.  Then any sensible combination of the following git commands will work:
<pre>
git add [files]         queues the files for commit
git commit -a [files]   queues and commits changed files including deletions
git rm   file...        remove named files
git add -A              remove files that have been deleted from the file system
</pre>
More complex variants are possible - see man git-rm.
</p>
<h3>Renaming files</h3>
<p>This necessarily involves a delete and then an add but can be done with the git-mv command.
This works with directories and several files can be moved to a new directory with one command.
</p>

<a name="branches"></a>
<h3>Operating branches: split, update and merge</h3>
<p>The following commands are used to manage branches in a local repository:
<pre>
git branch              to list existing branches
git branch fred         to create a new branch fred
git checkout fred       to switch to using fred
git checkout master     to switch back to using master
git merge fred          to merge commits from fred into the current (master) branch
git branch -D fred      to delete a branch that is no longer required
</pre>
</p>
<p>After making some commits in the local repository, the following commands would be used to fetch-and-merge changes from the master repository before pushing our commits into the master repository.  This assumes that we have the alias 'origin' set up to point to the master repository, which would automatically be the case for a cloned repository.  (Aliases can be displayed with the 'git remote -v' command.)
<pre>
git fetch origin        to fetch changes from origin into our repository
git merge origin        to merge changes from origin into our repository
git pull origin         the same as doing a fetch then merge
git push origin         to push our changes to origin (any conflicts must be resolved first)
</pre>
</p>

<h3>Merges, fast-forward and rebasing</h3>
<p>A straightforward merge, where there have been no simultaneous commits created in parallel in other repositories, is called a fast-forward merge.  This means a branch can be advanced along a linear sequence, so we end up with a simple, linear history.  If there have been parallel commits, then 'git merge' would actually introduce a new merge-commit to tie the two commits together.  This is called a non-fast-forward merge.
</p>
<p>When a non-fast-forward merge occurs, there is always the possibility that a conflict occurs. In this case, 'git merge' will leave conflict markers in the files and instruct you to resolve the conflicts. When you are finished, you would issue a 'git commit -a' to create the merge commit.
</p>
<p>You can 'rebase' your local branch so that when you push your changes you will get a linear history, even for non-fast-forward merges.  <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#using-git-rebase">This</a> page explains how to do this and <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#bisect-merges">this one</a> explains why it is a good idea.  However, <font color="red"><i>you should not rebase any changes that might already have been fetched by anyone else (i.e. anything in the master repository).</i></font>  <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#problems-With-rewriting-history">This page</a> explains why not.
</p>


<h3>Tagging a release/build</h3>
<p>Tag a release using the 'git tag' command.  Use the -a option so that you get an annotated tag (otherwise Git will create a 'lightweight' tag, which is not so useful - <a href="http://www.rockstarprogrammer.org/post/2008/oct/16/git-tag-does-wrong-thing-default/">this post</a> explains why).
<pre>
git tag -am "tag comment" tagname
</pre>
</p>

<h3>How are tags combined?</h3>
<p>man git-merge reveals how branches are combined and we need to know the converse - how to clone a previous version of a branch before the merge.
</p>
<p>TBD
</p>

<h3>Other notes</h3>
<p>TBD (add notes from emails)
</p>
<p>rebase looks like something we may want to use (eg after fixing a bug in an old verrsion) but apparently there are pitfalls.
</p>
<p>more terminology: "non fast forward push error", "fetch and rebase"
</p>

</fieldset>
