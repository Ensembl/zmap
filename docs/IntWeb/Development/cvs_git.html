<h2>Version Control</h2>
<p>I'm still working on this, it's a bit ragged at the end especially. I'll have to run through all the commands and cut and paste real examples...
</p>

<fieldset><legend>Version control for ZMap</legend>

<p>Historically ZMap has used CVS to store source code documentation and scripts and prior to constructing version 1.0.0 of ZMap it is intended to switch to using git.  There are a subset of CVS commands used by the ZMap team plus a few custon scripts and we envisage a similar situation with git - the intention is to keep things as simple as possible. There are two main sections to this page: a) <a href="Design_notes/build/cvs_git.shtml#convert">converting to git</a> and b) <a href="Design_notes/build/cvs_git.shtml#usegit">Using git</a>.
</p>

<h3>Documentation provided (git)</h3>
<p>Quite a lot of readable docs are available online:
<ul>
<li> <a href="http://git-scm.com/documentation"> git front page</a>
<li> <a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html"> tutorial/easy introduction</a>
<li> <a href="http://www.kernel.org/pub/software/scm/git/docs/gitcvs-migration.html"> importing from CVS</a>
<li> <a href="Development/cvs_git.shtml#gitflow">git flow</a>
</ul>
The reader is advised to refer to these and others on the git web site as well as this document.
</p>
Command line help is also quite user friendly:
'git ?help' brings up a list of commands (like CVS) and individual commands produce a Unix man-page. You can also access these with (eg) 'man git-merge' like commands for various git features.

</fieldset>


<a name="convert"></a>
<fieldset><legend>Converting ZMap CVS to git</legend>
<h3>Orientation</h3>
<p>
In the interests of simplicity we aim to keep the last CVS version as a backup and simply import all the files tags and commit history using the tools provided by git with default paramters.  We see little benefit in detailed older versions as there are no legacy user issues of relevance.
</p>
<p>
</p>Other groups have imported CVS histories in great deatil but this is reputedly a tricky and time consuming process (eg <a href="http://lwn.net/Articles/409635/">PostgresSQL</a>).

<h3>Importing from CVS</h3>
<p>Creating a repository from an existing CVS checkout is trivial.  Importing change history is thought to be relatively simple and requires a program called cvsps, which is available in /usr/bin on the deskpros.  This program detects 'patchsets' consisting of commits of multiple files.  Various people suggest that the import process is imperfect and that CVS commits are not grouped together appropriately in all cases.
</p>
<p> As we intend to save the last CVS as a backup then we can work with a flat import with all files apparently created at the same time.  Previous versions can be checked out from CVS if needed.  Indeed, git allows the developer to re-invent history by re-basing a repository on another version and this implies that it will be possible to checkout an old version from CVS, import it into git and rebase the original to that, which then implies that a modification to the old version can be merged into the current. <b>NOTE</b>: this circumstance is thought to be very unlikely and possibly complex, It will be much more practical to import the ZMap tags and restrict the use of old versions to offcial builds.
</p>
<p>
An experiment reveals that importing the ZMap CVS take about 30 minutes, and this imports all the tags and commit history, and has master and origin branches. This is in ~zmap/git and uses 43MB of disc space, compared with 69MB for a ZMap source tree with object files. Git can be told to ignore certain files (eg *.o).
This could work as a master copy similar to the existing CVS repository.  The documentation states that this import is incremental  and changes in the existing CVS can be added to the repository, which implies that it is possible to switch from CVS to Git with no risk ? they can be run in parallel (although there's no mention of exporting back to CVS).
</p>

<h3>Hosting the git repository</h3>
<p>Our use of  CVS is to provide a master copy of the source with individual checkouts being made by developers that are uploaded to the master copy when tasks are completed.  For distribution we make a tarball of the source - there is no public access to the repository.
</p>
<p>To emulate this with git the following is proposed:
<ul>
<li> a master repository, say zmap.git, will be stored in git.internal.sanger.ac.uk:/repos/git/annotools/
<li> git clones will be made by developers and these may include branches (or multiple clones created)
<li> after completing development the developer will push thier updates to the master clone
<li> official builds will only be created from the master copy in ~zmap/git.  Note that this is not the distributed model espoused by git but instead the 'person-independant' philosophy practiced by the Zmap team.  It also imples that the master copy only contains stable tested code
<li> distribution tarballs are made by 'offcial' builds from ~zmap/git
</ul>
Note that due to file permissioning issues developers need to be in a 'zmapteam' group to upload their work. An alternative way would be for them to log in as zmap and pull their updates for thier clones instead of pushing them.
</p>
<p>
Note that repositories in this location will be available on gitweb (<code>http://git.internal.sanger.ac.uk</code>) unless you remove world-read permission.
</p>

<h3>Simple differences between CVS and git</h3>
<p>Note should be take of the following:
<ul>
<li> unlike CVS git does not add a version/timestanp in the files themsleves (in CVS via $Id: cvs_git.html,v 1.3 2011-03-21 11:30:52 gb10 Exp $), which is arguably better in that the version control is externs the what is being controlled - CVS cannot do this for binary files for instance.
<li> CVS has been set up to checkout files as read only and to require files to be explicitly opened for editing whereas git records file permissions and therefore emulating this kind of behaviour is not ideal. Instead git is aware of changes to files and only those changes that have been explictly added will be committed to the repository (you have to add chenges in content rather than files) - so git provides a similar kind of control but allows instant editing.  Use git-show to see what files have been changed or added.
</ul>
</p>


</fieldset>

<a name="usegit"></a>
<fieldset><legend>Patterns of use in the ZMap development environment</legend>
<p>
git is very powerful and has far more features than are needed by the ZMap team and here we define the subset of git features that we intend to use and a number of expected tasks.  Note that our use of git is entirely local - there are no public repositories and no use of emailed updates.
</p>
<p><b>NOTE</b> that what appears below is a quick summary and users should refer to the git man-pages, which are very informative and have examples.
</p>

<h3>Import a CVS tree into git</h3>
<p>Since inception the Zmap source tree has not been branched in CVS and this makes the import process much simpler.  Simply run these commands with CVS configured as normal:
<pre>
cd ~zmap/git
git cvsimport -a -v ZMap
</pre>
This takes about 30 minutes (or maybe slightly longer), after which the ~/zmap/git directory contains a copy of the CVS source tree.  It runs through the same process of fetching and then compressing several times - don't panic!
</p>

<h3>Create a bare repository</h3>
<p>The master repository should be a bare repository; that is, a repository that just contains the .git directory but not the checked-out working tree.  This is because if you push to a repository that has a checked-out working tree, the working tree will not be updated by the push.  This may lead to unexpected results if the branch you push to is the currently checked-out branch.
</p>
<p>We can create a bare repository from any existing repository, e.g. from ~zmap/git.  Create the master repository as the zmap user to make sure the owner and group are correct.
<pre>
cd /repos/git/annotools
mkdir zmap.git
cd zmap.git
git --bare init --shared
git --bare fetch ~zmap/git master:master
</pre>
</p>
The --shared option makes the repository group-writable.
</p>
<p>
Edit the <code>description</code> file in <code>zmap.git</code> to set the description that will be visible on gitweb.
</p>

<h3>Setting up access permissions</h3>
<p>We have set the master repository to be group-writable with the --shared option in the above section.  We need to make sure the owner of the repository is the zmap group, which will already be the case if we created the master repository as the zmap user (if not, then we can change the group with chown or chgrp, but this will overwrite the 's' in the group permissions, so we would need to put that back).  We should also run the following 'setfacl' commands to ensure that all file permissions are inherited when new files are created.
<pre>
export GIT_DIR=/repos/git/annotools/zmap.git    (bash?)
setenv GIT_DIR /repos/git/annotools/zmap.git    (tcsh?)

setfacl -d -m g::rwx $GIT_DIR/{refs,objects,branches}
setfacl -m g::rwx $GIT_DIR/{refs,objects,branches}
setfacl -m g::rw $GIT_DIR/HEAD
</pre>
</p>
<p>Our repository contents should now look something like this:
<pre>
drwxrwsr-x+ 2 zmap zmap    6 2010-11-30 09:52 branches
-rw-rw-r--  1 zmap zmap  126 2010-11-30 09:52 config
-rw-rw-r--  1 zmap zmap   58 2010-11-30 09:52 description
-rw-r--r--  1 zmap zmap 1066 2010-11-30 09:52 FETCH_HEAD
-rw-rw-r--  1 zmap zmap   23 2010-11-30 09:52 HEAD
drwxrwsr-x  2 zmap zmap 4096 2010-11-30 09:52 hooks
drwxrwsr-x  2 zmap zmap   20 2010-11-30 09:52 info
drwxrwsr-x+ 4 zmap zmap   28 2010-11-30 09:52 objects
drwxrwsr-x+ 4 zmap zmap   29 2010-11-30 09:52 refs
</pre>
<p>

<h3>Registering with git</h3>
<p>To make normal commands easier it is recommended to define users and shortcuts:
Each user should register their name and email address so that this information can be recorded against commits, e.g. with:
<pre>
deskpro1[fred]5: git config --global user.name "fred"
deskpro1[fred]6: git config --global user.email fred@sanger.ac.uk
</pre>
If you cloned a repository, then by default you will already have the 'origin' alias set up to point to the repository that you cloned.  Use 'git remote -v' to view existing aliases.  You can also explicitly set up an alias to a specific repository as follows:
<pre>
deskpro1[fred]16: git remote zmap ~zmap/git
(Note: in out example this is not a repository, try git.internal.....
Acutally not needed here so skip this)
</pre>
</p>

<h3>Other useful configuration</h3>
<p>Git can <a href= http://progit.org/book/ch7-1.html#colors_in_git>color its output</a>.  To turn on default terminal coloring use:
<pre>
git config --global color.ui true
</pre>
</p>
<p>You can create your own formatted/colored output from the log command using the --pretty option.  The following gives an example.  You can use --pretty with 'git log' directly, but here I've set up alias commands, 'lg' and 'tg', to show a nicely formatted log and tag list respectively (works best on a black background!).  You could also set the 'format.pretty' config item to change the default format for the log command.
<pre>
git config --global alias.lg "log --graph --pretty='format:%Cgreen%ai%Creset - %Cred%h%Creset %C(yellow)%d%Creset %s %C(cyan)<%an>%Creset %Cgreen(%ar)%Creset'"
git config --global alias.tg "log --tags --simplify-by-decoration --pretty='format:%Cgreen%ai%Creset %C(yellow)%d%Creset'"
</pre>
<pre>
mac18480i[gb10]16: git tg
<font color="green">2010-12-07 18:25:55 +0000</font>  <font color="yellow">(BUILD-2010_12_07)</font>
<font color="green">2010-12-06 16:07:47 +0000</font>  <font color="yellow">(BUILD-2010_12_06)</font>
<font color="green">2010-11-30 16:20:39 +0000</font>  <font color="yellow">(new-build-system, dev)</font>
<font color="green">2010-10-19 09:52:54 +0000</font>  <font color="yellow">(RELEASE-4_9_54)</font>
<font color="green">2010-10-18 14:06:53 +0000</font>  <font color="yellow">(test-release-pre-new-dotter)</font>
<font color="green">2010-06-11 09:38:31 +0000</font>  <font color="yellow">(RELEASE-4_9_53)</font>
<font color="green">2010-05-06 09:36:42 +0000</font>  <font color="yellow">(RELEASE-4_9_52)</font>
<font color="green">2010-05-05 15:17:24 +0000</font>  <font color="yellow">(RELEASE-4_9_51)</font>
<font color="green">2010-04-21 17:23:03 +0000</font>  <font color="yellow">(RELEASE-4_9_50)</font>
<font color="green">2010-03-26 15:17:20 +0000</font>  <font color="yellow">(RELEASE-4_9_49)</font>
<font color="green">2010-02-26 16:37:06 +0000</font>  <font color="yellow">(RELEASE-4_9_48)</font>
<font color="green">2009-11-03 18:28:23 +0000</font>
</pre>
</p>
<p>You can specify a tool to view diffs with by using 'git difftool' rather than 'git diff'.  To set the default tool used by difftool to, say, diffuse, use:
<pre>
git config --global diff.tool diffuse
</pre>
</p>

<h3>Setting up repository options</h3>
<p>As git allows you to perform operations on all files that have been modified, there is value in having it ignore certain files, e.g. object and temporary files.  This is done by specifying file names or patterns in a file called '.gitignore' (generally placed in the top level directory of the project), or in .git/info/exclude.  Generally, .git/info/exclude is used for things that are applicable to your local repository only.  A .gitignore file can be checked in as part of the project, so it can be used for anything that is also useful to other developers on the project.
</p>
<p>For example, the .gitignore file might contain:  (DS_Store is a mac thing)
<pre>
*.[oa]
*~
.DS_Store
</pre>
</p>
<p>and my local .git/info/exclude file might contain:
<pre>
my_notes.txt
mylog/*
</pre>
</p>

<h3>Clone a repository</h3>
<p>Developers should not work on the master respository but instead make a clone of it.
<pre>
mac18480i[gb10]253: mkdir git
mac18480i[gb10]254: cd git/
mac18480i[gb10]255: git clone git.internal.sanger.ac.uk:/repos/git/annotools/seqtools.git
Cloning into seqtools...
remote: Counting objects: 2532, done.
remote: Compressing objects: 100% (463/463), done.
remote: Total 2532 (delta 2064), reused 2532 (delta 2064)
Receiving objects: 100% (2532/2532), 1.53 MiB, done.
Resolving deltas: 100% (2064/2064), done.
</pre>
Or for ZMap:
<pre>
mac18480i[gb10]253: mkdir zmap
mac18480i[gb10]254: cd zmap
mac18480i[gb10]255: git clone git.internal.sanger.ac.uk:/repos/git/annotools/zmap.git ZMap
Cloning into ZMap...
</pre>
<pre>
mac18480i[gb10]256: cd seqtools/
mac18480i[gb10]257: ls -a
.		..		.git		.gitignore	src
</pre>
After this files may be edited as normal, programs compiled and tested.
</p>


<h3>Editing files</h3>
<p>Edit the files as normal. When finished use:
<pre>
git add [files]
</pre>
to queue the changes for commit.  Modified files that have not been added using 'git add' will not be committed by default, but you can use the -a option to commit all files that have been modified or deleted.  New files must always be added with 'git add' before they will be tracked.
<pre>
git commit -a
</pre>
</p>

<h3>Showing git/ file status</h3>
<p>The command:
<pre>
git status
</pre>
lists all modified files and all changes addded for commit.
<pre>
git show
git diff
</pre>
Reveal the differences between current and indexed files.

<h3>Committing files</h3>
<p>
'git commit' will commit all files staged with 'git add' or specific files may be specified. The flag -a tells git to commit all files that have been changed, which includes deletions (but not additions).
<pre>
git commit -a -m "this is my new wizzo feature"
</pre>
<pre>
git add zmapWorking.c
git commit -m "a small bug fix" zmapWorking.c
</pre>
</p>

<h3>Resolving Conflicts</h3>
<p>Unlike CVS, a commit is to the current local clone and there can be no editing conflicts arising (this assumes that each developer clones the master).  Likewise different branches from a single clone have conflict free histories.   Conflicts can occur on merging branches or pulling fields from another repository (pull does a fetch and merge).
</p>
<p>As for CVS, conflicts are indicated with marker lines such as:
<pre>
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt
Conflict resolution is hard;
letï¿½s go shopping.
=======
Git makes conflict resolution easy.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
</pre>
Please refer to 'man git-merge' or <a href="Design_notes/build/cvs_git.shtml#branches">operating branches</a> below for the merge process.
</p>

<h3>Adding and Deleting files</h3>
<p>
Create or delete the files using normal linux commands.  Then any sensible combination of the following git commands will work:
<pre>
git add [files]         queues the files for commit
git commit -a [files]   queues and commits changed files including deletions
git rm   file...        remove named files
git add -A              remove files that have been deleted from the file system
</pre>
More complex variants are possible - see man git-rm.
</p>
<h3>Renaming files</h3>
<p>This necessarily involves a delete and then an add but can be done with the git-mv command.
This works with directories and several files can be moved to a new directory with one command.
</p>

<a name="branches"></a>
<h3>Operating branches: split, update and merge</h3>
<p>The following commands are used to manage branches in a local repository:
<pre>
git branch              to list existing branches
git branch fred         to create a new branch fred
git checkout fred       to switch to using fred
git checkout master     to switch back to using master
git merge fred          to merge commits from fred into the current (master) branch
git branch -D fred      to delete a branch that is no longer required
</pre>
</p>
<p>After making some commits in the local repository, the following commands would be used to fetch-and-merge changes from the master repository before pushing our commits into the master repository.  This assumes that we have the alias 'origin' set up to point to the master repository, which would automatically be the case for a cloned repository.  (Aliases can be displayed with the 'git remote -v' command.)
<pre>
git fetch origin        to fetch changes from origin into our repository
git merge origin        to merge changes from origin into our repository
git pull origin         the same as doing a fetch then merge
git push origin         to push our changes to origin (any conflicts must be resolved first)
</pre>
</p>

<h3>Merges, fast-forward and rebasing</h3>
<p>A straightforward merge, where there have been no simultaneous commits created in parallel in other repositories, can be done as a 'fast-forward' merge.  This means that a branch can be advanced along a linear sequence, so we end up with a simple, linear history.  If there have been parallel commits, then 'git merge' will introduce a new merge-commit to tie the two commits together.  This is called a non-fast-forward merge.  You do not get a merge-commit for a fast-forward merge, and therefore all history about which branch the changes were actually made on are lost.  By default, <code>git merge</code> does a fast-forward merge whenever possible, but you can override this using the <code>--no-ff</code> option.  This results in an empty merge-commit, but preserves the branch history.  This can be useful as a way of grouping related commits together (e.g. all of the commits that went into implementing a particular feature).  <a href="http://nvie.com/posts/a-successful-git-branching-model/">This page</a> describes a successful branching model that uses this method.
</p>
<p>When a non-fast-forward merge occurs, there is always the possibility that a conflict occurs. In this case, 'git merge' will leave conflict markers in the files and instruct you to resolve the conflicts. When you are finished, you would issue a 'git commit -a' to create the merge commit.
</p>
<p>You can 'rebase' your local branch to the one you want to merge it to so that when you merge your changes you will get a linear history, even for non-fast-forward merges.  <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#using-git-rebase">This</a> page explains how to do this and <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#bisect-merges">this one</a> explains why having a linear history can be really useful.  However, note that <font color="red"><i>you should not rebase any changes that might already have been fetched by anyone else (i.e. anything in the master repository).</i></font>  <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#problems-With-rewriting-history">This page</a> explains why not.  Also, as described above, when you have a linear history you will get a fast-forward merge by default and lose the branch history, which may not be what you want.  Perhaps the best of boths worlds is to do a rebase followed by a <code>git merge --no-ff</code>, effectively giving a linear history but also preserving branch history.
</p>

<h3>Compile info</h3>
<p>The programs should have some version info built into them that can be displayed via a help dialog to allow us to identify exactly what version of the source code was used to build the program. We can use the 'git describe' command to supply this information. This tells us the last tag that our code was based on, how many commits there have been since that tag, and the commit ID of the current commit. It can also tell us whether we are using a dirty tree if we use the --dirty option, e.g.
<pre>
mac18480i[gb10]137: git describe --dirty
v4.1.17-94-g1c9cd13
mac18480i[gb10]138: git describe HEAD~94
v4.1.17
### edit some files ###
mac18480i[gb10]139: git describe --dirty
v4.1.17-94-g1c9cd13-dirty
</pre>
</p>

<h3>Tagging a release/build</h3>

<p>Tag a release using the 'git tag' command.  Use the -a option so that you
get an annotated tag (otherwise Git will create a 'lightweight' tag, which is
not so useful -
<a href="http://www.rockstarprogrammer.org/post/2008/oct/16/git-tag-does-wrong-thing-default/">this post</a>
explains why).

<pre>
git tag -am "tag comment" tagname
</pre>
</p>


<h3>Push/Pull and tags</h3>

<p>By default when you issue a <b>git pull</b> you get the tags in the repository, when you do a
<b>git push</b> tags you created in your clone are not by default passed to the repository.
To get the tags into the repository you need to the --tags option:</p>

<pre>

Tag your clone and push the tag to the repository:

git pull
git tag -a -m "your reason for tag" YOUR_TAG
git push --tags


Get any tags from the repository:

git pull

</pre>




<h3>How are tags combined?</h3>
<p>man git-merge reveals how branches are combined and we need to know the converse - how to clone a previous version of a branch before the merge.
</p>
<p>TBD
</p>

<h3>Other notes</h3>
<p>TBD (add notes from emails)
</p>
<p>rebase looks like something we may want to use (eg after fixing a bug in an old verrsion) but apparently there are pitfalls.
</p>
<p>more terminology: "non fast forward push error", "fetch and rebase"
</p>

</fieldset>


<a name="gitflow"></a>
<h2>Git Flow - managing  development and release streams</h2>

<h3>Intro</h3>

<p>Git-flow is an add on package that allows easy maintainance of development
production and feature repositories/clones.See
<a href="http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/">here</a>
for a brief description and sales pitch.  </p>

<p>There are no doubt many way to work with git and we choose a few procedures
that work for us.</p>


<h3>Initialising the repository and your clone of the repository</h3>

<p>The <b>git flow init</b> command is advertised as being able to:</p>

<ul>
  <li>Set up a new repository
  <li>Add branches to an existing repository
  <li>Initialise a cloned repository
</ul>

<p>We used 2) and 3) and it does not seem to work smoothly. You have to create
the production and development branches in your local clone yourself otherwise
the command terminates, it doesn't seem to cope that easily with adding them to
an existing repository and you seem to end up with a redundant "master" branch.</p>

<p>Experiments show that the command does in fact work cleanly if you follow
the following sequence:</p>

<pre>
# Create an empty repository which gets called '.git'
&gt; git flow init
Initialized empty Git repository in /nfs/users/nfs_e/edgrif/CHECKOUT/GIT_TEST/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master] production
Branch name for "next release" development: [develop] 

How to name your supporting branch prefixes?
Feature branches? [feature/] 
Release branches? [release/] 
Hotfix branches? [hotfix/] 
Support branches? [support/] 
Version tag prefix? [] V_


# clone this repostiory:
&gt; git clone ./.git my_git
Cloning into my_git...
done.


# This produces a nice clean structure with develop as the current branch:
&gt; git branch -a
* develop
  remotes/origin/HEAD -> origin/develop
  remotes/origin/develop
  remotes/origin/production


# Before using git flow on your clone make sure you have a local "production" branch by checking out "production"
&gt; git checkout production
Branch production set up to track remote branch production from origin.
Switched to a new branch 'production'

&gt; git branch -a
  develop
* production
  remotes/origin/HEAD -> origin/develop
  remotes/origin/develop
  remotes/origin/production


# Now run git flow init to set up branching names/structure <b>exactly</b> as you did when
# you set up the repository
&gt; git flow init

Which branch should be used for bringing forth production releases?
   - develop
   - production
Branch name for production releases: [production] 

Which branch should be used for integration of the "next release"?
   - develop
Branch name for "next release" development: [develop] 

How to name your supporting branch prefixes?
Feature branches? [feature/] 
Release branches? [release/] 
Hotfix branches? [hotfix/] 
Support branches? [support/] 
Version tag prefix? []


# You end up with the same structure and branch names.
&gt; git branch -a
* develop
  production
  remotes/origin/HEAD -> origin/develop
  remotes/origin/develop
  remotes/origin/production


# Now you can add files to your clone and push to the repository.
</pre>


<h3>Creating branches locally and sharing these via the remote repository</h3>

<p> From a fresh git repository on git.internal.sanger.ac.uk we can create a
local clone as above.  In the local clone we can create new branches:

<pre>
> git branch develop
> git branch production
</pre>
and then push these to the remote (git.internal.sanger.ac.uk):
<pre>
> git push origin develop
> git push origin production
</pre>
after which we can see these from another clone:
<pre>
> git branch -a
  develop
  master
* production
  remotes/origin/HEAD -> origin/master
  remotes/origin/develop
  remotes/origin/master
  remotes/origin/production
</pre>
From another clone we would need to do:
<pre>
> git pull origin
</pre>
to see the branches locally, or we could check them out.
</p>

<h3>Using git flow</h3>
<p>We set up git flow to create feature branches from develop and can create a new feature branch like this:
<pre>
> git flow feature start my_thing
</pre>
then edit some files, and commit them.
</p>
<p> After committing the files we can switch branches using (eg):
<pre>
> git checkout feature/BAM
</pre>
which will change all the files as needed. <b>NOTE</b> that there appears to be a bug in git flow in that after creating a new feature branch and editing a file then git checkout will switch branches but not change the files. The files are flagged as modified, so that gives us some warning.  After doing a commit the git checkout will refuse to switch if changes are pending.
'git add' does not affect this, you must commit a file first.  It's possible the bug is in plain git of course!
</p>

<h3>Updating documentation</h3>
<p>Non feature specific documentation should be updated using the branch develop, which will allow it to be pushed/merged into the remote repository easily.
</p>

<h3>Notes on untracked files</h3>
<p>Documentation is generated via a script from source html files into shtml to add a menu on the LHS and it is wise to regenerate this on occasion, the shtml will not be updated via git checkout.
</p>

<p>The build system generates a lot of makefiles via bootstrap and runconfig and these are untracked. Switching branches may require running these again.
</p>


<h3>Here are some notes on git flow usage from the git flow downloads page</h3>


<h4>Typical usage:</h4>

<pre>
Initialization

To initialize a new repo with the basic branch structure, use:

    git flow init

This will then interactively prompt you with some questions on which branches
you would like to use as development and production branches, and how you would
like your prefixes be named. You may simply press Return on any of those
questions to accept the (sane) default suggestions.


Creating feature/release/hotfix/support branches

    * To list/start/finish feature branches, use:

        git flow feature
        git flow feature start &lt;name&gt; [&lt;base&gt;]
        git flow feature finish &lt;name&gt;

      For feature branches, the &lt;base&gt; arg must be a commit on develop.


    * To list/start/finish release branches, use:

        git flow release
        git flow release start &lt;release&gt; [&lt;base&gt;]
        git flow release finish &lt;release&gt;

      For release branches, the &lt;base&gt; arg must be a commit on develop.


    * To list/start/finish hotfix branches, use:

        git flow hotfix
        git flow hotfix start &lt;release&gt; [&lt;base&gt;]
        git flow hotfix finish &lt;release&gt;

      For hotfix branches, the &lt;base&gt; arg must be a commit on master.


    * To list/start support branches, use:

        git flow support
        git flow support start &lt;release&gt; &lt;base&gt;

      For support branches, the &lt;base&gt; arg must be a commit on master.
</pre>




</fieldset>
