<!-- $Id: canvas_tweaks.html,v 1.4 2010-09-15 10:43:14 mh17 Exp $ -->

<h2>Speeding up the use of the Foo Canvas</h2>

<fieldset><legend>Basic Features made simple again</legend>
<h3>The problem: Basic features have been made complex</h3>
<p>
All ZMapWindowCanvasItems are currently FooCanvasGroups and contain lists of features for background underlay feature and overlay and changing these to be simple FooCanvasItems may offer a significant performance improvement and simplify a lot of code and free up a lot of memory.  The initial display of ZMap is dominated by alignments (eg SwissProt and TrEMBL) which typically contain 90% of all features on display.
</p>
<h3>Caveats</h3>
<h4>Complexity is not used? </h4>
<p>Despite each basic feature consisting of several lists of canvas items these lists are empty and may not cause a significant delay.
</p>
<h4>Side effects</h4>
<p>When alignments get bumped their x-coordinate is changed and extra lines and glyphs are drawn on the canvas.  Use of the complex ZMapWindowCanvasItem structure may be necessary to do this.
</p>

</fieldset>

<fieldset><legend>Summarise Columns</legend>
<p>See also RT #177032, where this text orginated.</p>
<h3>Displaying invisible features slows ZMap down</h3>
<p>
Display time in ZMap is dominated by a few heavily populated columns eg trembl may have 50k features but the majority of these features are obscured by others and cannot be seen. As operating the foo canvas takes 90% of the display time and a complete feature context can be scanned very quickly (eg 50ms to reverse complement all features, compared with 10sec to display) it may be possible to speed up this display by not adding invisible features to the canvas.  Note that due to the display format of alignments (centered rectangles) we can resonably expect to loose up to 98% of features off the display for a column like TrEMBL - if the column is 1000 pixels deep we cannot need to display more than 1000 features to give the same visual appearance.  There may still be some overlap caused by the simple scan algorithm.
</p>
<p>
This is a similar process to the idea of a summary display as to be provided by otterlace on request, but the difference is that ZMap would still have all the data and only real features will be used. The argument for having ZMap perform the necessary calculations is that ZMap knows when features become obscured at different zoom levels as it knows about pixel coordinates.
</p>
<p>
This process only applies to un-bumped columns and to implement this a column with an appropriate style parameter would be processed before display at the current zoom level.  This parameter defines the minimum zoom level at which to apply the summarising algorithm:
<pre>
[pep-align]
alignment-summarise=0.1
</pre>
</p>

<h4>Algorithm</h4>
<p>
<ul>
<li> sort the featureset into vertical order
<li> express features in canvas (pixel) coordinates (top, height, width)
<li> as features are displayed add their rectangles to a list in order of upper vertical coordinate
<li> if two rectangles next to each other have the same width combine them
<li> if a rectangle in the list is covered by the new/ combined one remove it
<li> if a rectangle covers the middle of a narrower one split the narrower rectangle into two
<li> rectangles may not overlap (strictly, including borders)
<li> when processing a feature if its width is &le; the min width of listed rectangles over the whole vertical distance do not display
<li> as features are processed remove rectangles from the list when they are out of range
</ul>

This uses little extra memory and comparisons are fairly quick as there is almost no searching involved.
Visibility is computed exactly and we can choose whether to display the items at the top or bottom of the foo canvas heap by sorting in reverse order.
</p>
<h4>Caveats</h4>
<p>
BumpCol would have to be changed to display the hidden features rather than moving thier x-coordinate. However bumping already includes adding lines and glyphs to the canvas and this should not be a significant problem.
</p>
<p>Functions such as 'List all Column Features' may have to be reviewed if they feed off the canvas data - perhaps some speed gains can be made by drawing features as hidden. (tests show about a 20-25% improvement by hiding all features.
</p>
<p> Displaying several featuresets in one column is more complicated especially when we consider that the summarise option is selected by a featureset's style.  It is possible so specify a style for a column abnd this perhaps provides some resolution despite allowing for mis-configuration.
However the intention was to speed up the display of featuresets like TrEmbl and SwissProt which normally appear in a column of thier own   It may not be worth implementing a comples way of combining featuresets like this, better to specify what happens if this is configured.  As a short term measure we will choose to summarise each featureset in a column independantly.
</p>
<h3>Implementation</h3>
<h4>Module and scope</h4>
<p>This will be a new module <b>zmapWindowContainerSummarise.c</b> and will operate on a ZMapWindowContainerFeatureSet, which may contain more than one featureset from the feature context.
</p>
<p>Note that in a view (which contains the feature context) if there are multiple windows open these are not constrained to be at the same zoom level (although you do have to unlock them first) and therefore it is not appropriate to maintain any flags in the feature context relating to this - all state information must be at the level of ZMapWindowCanvasItems.
</p>
<h4>Choosing featuresets and when</h4>
<p>Styles will be used to control whether or not to not display features.  This implies that it will be possible to select individual featuresets within a column for summarising.   Logically we could summarise columns other than alignments but as there are only two columns thought to be relevant (and they include only one featureset each) this will be phrased as an alignment mode option.  GF-splice glyphs look like another good candidate but as they are not rectangular features would require special code.
</p>
<p>We can also specify a minimum zoom level to do this at and avoid pointless computation.
</p>
<h4>Where to attach the filter</h4>
<p>We need to have access to canvas coordinates and this implies that we need to home in on the ItemFactory where these are calculated. In <b>zMapWinfowItemFactoryRunSingle()</b> a function  ((method)->method)() is called for each type of feature which creates and draws the ZMapWindowCanvasItem and when this is called the x and y coordinates have been calculated and adjusted for score if configured, but are in real world coordinates.  The foo canvas provides a function to convert called <b>foo_canvas_w2c()</b>.
</p>
<p>Filtering calls round this 'method. will allow us a single point of control and provides a clean interface to the rest of the code. There are futher offsets calculated later but as we need feature relative coordinates this is not relevant.
</p>
<h4>Data structures used</h4>
<p>We will use a simple linked list of reactangle structures and these will be freed at the earliest opportunity.  None of this has any permanence at all, although it will be held in the Window for use by callbacks.
</fieldset>
<fieldset><legend>Results</legend>
<p>After implementing the filtering algorithm as above we can see a big reduction in objects drawn and time used:
<table border="1" cellpadding="3" cellspacing="3">
<tbody><tr>
<th>FeatureSet</th><th>Features drawn</th><th>Total features</th> <th>Max list size<th>Time used</th><th>Previous Time </th><th>Time used</th>Ratio</tr>
<tr><td>TrEMBL</td> <td>722</td> <td>28922</td><td>4</td> <td>0.206sec</td> <td>4.865sec</td> <td>23.6</td></tr>
<tr><td>SwissProt</td> <td>554</td> <td>9563</td> <td>3</td><td>0.125sec</td> <td>1.606sec</td> <td>12.8</td></tr>
</tbody></table>
Given that the list of covered regions stays very short there seems little point in combining these as originally planned.  The reduction in time is a little dissappointing - it is related quite directly to the number of items drawn (1/40 for TrEMBL).  One deficiency is that the sorting of features is done using real coordinates and this may cause sorting by size (after start coordinate) to be ineffective and resolving this could result in significant further reductions.  However, trying this out gives no improvement, presumably due to the extra sorting overhead.
</p>
<h3>Some caveats</h3>
<p>This has so far been an experiment and there are some issues that need to be resolved:
<ul>
<li> some ZMap features such as list features in column may need to be adjusted to refernce the feature context rather than the canvas
<li> zoom appears to operate without doing a re-draw and this code needs to be adjusted to add featrues to the canvas
<li> bump column must draw the missing features
</ul>
The later two imply some performance overhead, although not as great as drawing the whole column in the first place.
</p>

</fieldset>

