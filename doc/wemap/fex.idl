//
// FEX client/server definition.
//
// Defines code to open a CORBA connection to a database and then
// use that connection to ask for feature information.
//


module FEX
{

  //
  // Basic structs and datatypes.
  //
  typedef sequence<string> StrSeq ;



  enum FeatureType { BASIC_FEATURE, HOMOL_FEATURE, EXON_FEATURE, TRANSCRIPT_FEATURE,
		     VARIATION_FEATURE, INTRON_FEATURE, BOUNDARY_FEATURE } ;

  enum Strand { NO_STRAND = 0, DOWN_STRAND, UP_STRAND } ;

  enum Phase { NO_PHASE = 0, PHASE_0, PHASE_1, PHASE_2 } ;

  enum HomolSubType { N_HOMOL, X_HOMOL, TX_HOMOL } ;

  enum BoundarySubType { CLONE_END, 5_SPLICE, 3_SPLICE } ;
  /* as in BLAST*, i.e. target is DNA, Protein, DNA translated */

  // Do we need this ?? not sure...
  enum Status { OK_STATUS, NO_WRITE_ACCESS } ;







  // Every feature, and hence set of features, will be of a particular class
  // and will have a name that identifies it to the user.
  // 
  struct FeatureSetInfo
  {
    String name ;					    // Name of feature set, e.g. "Genewise
							    // Predicted Genes".
    FeatureType type ;					    // Type of feature, e.g. IntronExon

    // How do these relate to "name" above...talk to rd.
    string category ;					    /* GFF_feature = BioPerl primary_tag */
    string source ;					    /* GFF_source = ?? */

    boolean isStrandSensitive ;
    boolean isFrameSensitive ;				    /* phase becomes important */
    boolean isScore ;

    HomolSubType homolType ;				    /* for Homols only */

    string targetDataSource ;				    /* for Homols only */

    BoundarySubType boundType ;				    /* for Boundaries only */

    StrSeq attributeList ;				    /* of char*, allowable attributes for
							       this fset */

  } ;

  typedef sequence<FeatureSetInfo> FeatureSetInfoSeq ;



  // Basic struct defining a single feature such as a gene, or a splice site.
  //
  struct Feature
  {
    DB_ID key ;						    // key of object in DB
    string name ;						    // string name of object
    union
    {
      Sequence IntronExon intron_exon ;
      Sequence Homol homol ;
      // etc. etc.
    }
  } ;


  // Struct holding a set of Features, all of one FeatureType.
  //
  struct FeatureSet
  {
    unsigned long num_features ;				    // Number of features in this set.
    sequence<Feature> features ;				    // Basically an array of features.
  } ;




  //
  // Interfaces to FEX
  //
  // Note that this interface allows us to get sequence and drawing information
  // independently from different databases. I expect that this bit will need
  // modification to cope with passing DB ids around. The constructors take
  // as one of the parameters the Connection, this is cached in the object
  // so we don't have to keep supplying it for every call.
  //

  // In CORBA speak the constructors for the objects will be via a factory
  // object which will do the actual business of construction.
  //
  interface connectDBFactory
  {
    Connection connectDB(in URL where_db_is, in string userid, in string passwd) ;

    // N.B. requires a Connection object so it knows which DB to go to, and a
    // Sequence_id/start/end to say which bit of sequence is to be retrieved.
    Sequence getSequence(in Connection db, in Sequence_id id, in int start, in int end) ;


    DrawMethod getDrawMethod(in Connection db) ;
  } ;



  // The database interface.
  // We use this to open a connection to the database, this can
  // then be used to get hold of features etc.
  interface Connection
  {
    // placeholder, this will need to be some kind of query type operation.
    // We need to somehow find out what at what level we can ask for sequences
    // from the database.
    Sequence_id findSequence(string clone_name) ;


    boolean checkWriteAccess() ;
    boolean setWriteAccess(boolean access) ;


    // destructor will close connection and clean up.
  } ;




  // The feature interface.
  // Constructor takes a reference to the database, some kind of identifier to
  // say which piece of sequence is required and coordinates.
  interface Sequence
  {
    // Should return names and info. about them, as these correspond to columns
    // in fmap we might as well get them all in one go.
    FeatureSetInfoSeq listAllFeatureSets() ;

    // Get info. for all features of a particular type.
    FeatureSetInfoSeq listTypeFeatureSets(in FeatureType type) ;

    // Get info. for a single feature type.
    FeatureSetInfo getFeatureSet(in string name) ;
    

    


  } ;


  //
  // The drawing method interface.
  // Each feature will be drawn with in a particular style according to
  // its FeatureType, in addition the style may have been tailored for
  // feature (e.g. in foreground colour etc.).
  //
  interface DrawMethod
  {



  } ;



} ;










// Probably we will want to follow X Windows and replace all strings
// with atoms/keys call them what you want, but lets not worry about this
// just yet.


// NOTES:
//  we need to map a Feature to its FeatureType, how shall we do this ?
// Perhaps we should introduce a "key" now for this ??


