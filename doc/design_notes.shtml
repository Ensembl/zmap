<HTML>
<!--#include virtual="/perl/header" -->
<!--#set var="author" value="edgrif@sanger.ac.uk" -->


<HEAD>
<TITLE>ZMap Design</TITLE>
</HEAD>

<BODY>

<blockquote>
<P>The purpose of this document is to be a repository for all aspects of the design
of ZMap.

<P>Pictures are allowed, just include them in the cvs directory.



<H1>Requirements, Wish Lists, Suggestions etc.</H1>

<H2>Requirements</H2>

<P>Record anything here that is essential to ZMap.


<H3>Mapping in the client</H3>

<P>We should strongly consider putting a modified (i.e. acedb-less SMap) into
the client, this would allow the client to map different sorts of data onto
its virtual sequence provided it had the initial mapping from the new data
to its own virtual sequence.

<P>This would be very powerful because it would mean the client could accept
data from many sources and map it as long as it had the extent of the data
in the virtual sequence.


<H3>How to indicate strand</H3>

<P>In acedb we have traditionally had the down strand to the right and the up strand
to the left of the scale, this has some advantages but could be augmented visually
with exons that had pointy bits to show their direction etc.

<P>We could go for everything being shown on one side of a scale but this seems
a bit retrograde to me, the display is actually something that marks the fmap
out from other viewers in a good way.




<H3>Richer glyph set</H3>

<P>We need a richer glyph set, perhaps with exon shapes that indicate direction and
other such stuff, e.g. how about indicating start/end_not_found etc.




<H2>Wish List</H2>

<P>Record anything here that you would like to be considered but is non-essential.

<ul>
  <li>Allow user to interactively retitle a window, v. useful when there are lots
      of fmap windows on a screen.
  <li>Prevent users from zooming in/out to the point where the drawing code breaks, particularly
      for zooming in where lines start to randomly appear/disappear.
</ul>




<H1>Design</H1>


<H2>Overview</H2>

<P>


<H2>Documentation</H2>

<P>

<h3>Source Code docs</h3>

<p>We are using the
<A href="www.doxygen.org/index.html">doxygen package</A>
for documenting our source code. This seems to work well
and does just about everything we need, it builds and improves on the DOC++ package which seems
to no longer be under active development.

<P>Some notes about using doxygen:

<ul>
  <li>doxygen looks for C comment blocks that start with " <b>/*!</b> ".
  <li>For C language files it is imperative to have a " <b>/*! \file */</b> " special
      comment in each file to be documented otherwise doxygen will <b>not</b> process the file.
</ul>

<P>See <b>zmapCongif/zmapConfig.c</b> for an example of how to document code.


<H2>Configuration Files</H2>

<P>The Lexical Scanner package within GLib is used to read and write configuration files.
The package requires a fair bit of work from the applications side to process stanzas
and so on but using it has the advantage that we do not need to link in any further libraries.
We could for instance have used the libgnome gnome-config calls, (see:
http://developer.gnome.org/doc/API/2.0/libgnome/libgnome-gnome-config.html) but this would have
required linking in the whole of the gnome application stuff).




<h3>Gnome Canvas</h3>
<p>Be a good idea to get rid of the graph package altogether if we can. Gnome Canvas
seems a good candidate to replace it, but we need to check a few things first:
<ul>
  <li>Can it output PostScript & Gif as well as to the screen?
      <p><font color="green">Ans: I think so.  This
      <a href="http://mail.gnome.org/archives/gnome-print-list/2003-January/msg00023.html">thread</a>
      from the gnome archives suggests such an interface was written in January 2003 and that it
      now lives in libgnomecanvas.  There might be an example of how to use it in gnome-print/tests.</font>
      
  <li>How efficiently does it clip overlapping display objects?
      <p><font color="green">Ans: Well, I think.  I've read various bits that imply it's intelligent in this way.
      </font>
      
  <li>Can we paint a bigger area than is actually visible in the window so scrolling
      to an area out of view is quick?
      <p><font color="green">Ans: yes, see
      <a href="http://developer.gnome.org/doc/books/WGA/gnome-canvas-using.html">here</a>.
      You'll need to scroll down a page to the The Scrolling Region subheading.</font>
      
  <li>Can we make it (I'm almost certain we can) not display stuff which is smaller
      than a given size, so it doesn't waste effort drawing stuff that's too small
      to be useful?  
      <p></p>
  <li>Where possible, we should be using the gnome wrapper datatypes for portability, and
      this raises the possibility of replacing the AceDB array functions with the gnome
      ones.  Whether the latter actually provide all the functionality of the former I
      haven't investigated, but it looks hopeful. GPtrArray is an array of pointers and
      the g_ptr_array_free() function includes a BOOL parameter to indicate whether or
      not the data pointed to is freed as well as the array itself.
  <li>According to developer.gnome.org/doc/whitepapers/canvas/canvas.html you can choose
      either of two rendering back-ends, an extremely fast one based on Xlib and another
      based on Libart.  PostScript is mentioned in the same breath as Libart.  However,
      the Libart (anti-aliased) one is quite a bit slower.
      <p>The Xlib model, used via GDK, runs well over networks. The Libart model provides
      a superset of the PostScript imaging model, allowing high-quality displays.
</ul>

<H3>Memory usage</H3>

<P>An experiment with creating rectangles in a gnome canvas showed that memory overhead
is quite high. The upshot is that each canvas_item rectangle costs about 2600 bytes, this
is probably because each one is represented by a GObject.

<P>You can see a plot of this data by running gnuplot and displaying the file
gnome_canvas_mem_usage from this docs directory.

<pre>&gt; gnuplot
gnuplot&gt; plot "gnome_canvas_mem_usage"
</pre>

<h3>Meeting Notes - Friday, 7th Feb, 2004</h3>
Rob has made some progress determining what the Zmap and Fmap graph calls do and how to replace them with gtk calls, etc.
The only relevant calls seem to be box, text and line, though there was one fmap circle call.  This should be fine.
He has created a zmap which uses gnomecanvas for the navigator and scrollable windows.  There are issues with the
scale bars which need to be addressed and there are numerous graph calls still included which need to be removed.
</p><p>
He also has a noddy application with a nice-looking scale bar with coordinates and a feature consisting of two
boxes joined by a bent line which also uses the canvas.  This is a useful application for prototyping aspects of
the project.
</p<p>
Ed has done lots of work on threading and now has an application which has a single thread running a rather thin
manager with multiple Zmaps, each of which will issue a DB thread to handle data manipulation.
</><p>
He returned from sunnier climes with a DAS2 server application which we hope to get set up so we can do some
work using that as well as AceDB as our data source.  He also has ExPat and libcurl libraries which do SAX simple
Access and gzip and zlib which handle compression.
</p><p>
Apparently this means our http can have &lt;stag&gt; content &lt;etag&gt; and our start callback routine will get
called when it encounters the stag, the content routine gets called for the content and the end routine gets called
for the etag.
</p>
<h3>Decisions</h3>
<ol>
<li>
    We decided that when the user hits the Split button it will just be the currently active window that is split, as
    in emacs, although the windows themselves will be held as a linked list at root level, so there won't be a
    hierarchy of windows in the application;  they'll all have the same status.
</li><li>
    There must be an arbitrary minimum size window which we'll allow to split, and beyond that the Split button
    will be greyed out.  This will be controlled by some publicised macro I think.
</li><li>
    We will only allow one sequence per Zmap.  If they want another sequence, they'll have to run another Zmap.
</li><li>
    We will retain the concept of three levels of scrolling.  The main sequence will show as some sort of slider bar
    covering the entire height of the navigation panel.  This can be thought of as range 'a'. The user can scroll
    within this area but the display won't change until buttonup, at which point the lights will dim.  While moving
    the scroll bar, a little window should show the current coordinate, so they know where they are in the scroll.
    <p>
    Within that is
    the sequence which has been calculated, roughly 3 times the amount that can be displayed in the window.  This
    is currently shown as a light grey area within the navigation panel and can be thought of as range 'b'.
    <p>
    We're thinking of adding a small scroll bar to this greyed are to allow the user to scroll within the calculated
    part of the sequence.  We'd need to add extra scroll bars as the user split the screen, one per window. The handle
    would indicate roughly where in area 'b' the window display 'c' would be.     Ed thinks
    recalculating this area as we scroll would be time-consuming, so we'd have to just redo it on buttonup, but I'm
    not convinced yet.  If he's right, we'll need a little window showing the current coordinate for each 'c' window.
    <p>
    Finally, there is the range actually on display, range 'c'. This is scrolled with the current scrolled window
    scrollbars and the display scrolls as you do it.
</li><li>
    We'll need drag bars on the top and bottom of the calculated area b, so the user can stretch it, and the code
    must supplement the SEGS array rather than recalculate it from scratch.
</li><li>
    When we calculate, we always calculate whole objects, so if a feature overlaps into the void, we include it in
    our calculated area, though we don't actually display it.  When the user stretches the calculated area, we again
    calculate whole objects in both directions, then throw away duplicates, so we never have partial or duplicated
    objects.
</li>



</blockquote>
<HR>

<!--#include virtual="/perl/footer" -->

</BODY>
</HTML>
