<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>ZMap Design</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.2  (Linux)">
	<META NAME="CREATED" CONTENT="20041209;15311400">
	<META NAME="CHANGED" CONTENT="20041209;15390800">
	<!--#include virtual="/perl/header" -->
	<!--#set var="author" value="edgrif@sanger.ac.uk" -->
</HEAD>
<BODY LANG="en-GB">
<BLOCKQUOTE>The purpose of this document is to be a repository for
all aspects of the design of ZMap. 
</BLOCKQUOTE>
<BLOCKQUOTE>Pictures are allowed, just include them in the cvs
directory. 
</BLOCKQUOTE>
<H1 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Requirements,
Wish Lists, Suggestions etc.</H1>
<H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Requirements</H2>
<BLOCKQUOTE>Record anything here that is essential to ZMap. 
</BLOCKQUOTE>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Mapping
in the client</H3>
<BLOCKQUOTE>We should strongly consider putting a modified (i.e.
acedb-less SMap) into the client, this would allow the client to map
different sorts of data onto its virtual sequence provided it had the
initial mapping from the new data to its own virtual sequence. 
</BLOCKQUOTE>
<BLOCKQUOTE>This would be very powerful because it would mean the
client could accept data from many sources and map it as long as it
had the extent of the data in the virtual sequence. 
</BLOCKQUOTE>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">How
to indicate strand</H3>
<BLOCKQUOTE>In acedb we have traditionally had the down strand to the
right and the up strand to the left of the scale, this has some
advantages but could be augmented visually with exons that had pointy
bits to show their direction etc. 
</BLOCKQUOTE>
<BLOCKQUOTE>We could go for everything being shown on one side of a
scale but this seems a bit retrograde to me, the display is actually
something that marks the fmap out from other viewers in a good way. 
</BLOCKQUOTE>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Richer
glyph set</H3>
<BLOCKQUOTE>We need a richer glyph set, perhaps with exon shapes that
indicate direction and other such stuff, e.g. how about indicating
start/end_not_found etc. 
</BLOCKQUOTE>
<H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Wish
List</H2>
<BLOCKQUOTE>Record anything here that you would like to be considered
but is non-essential. 
</BLOCKQUOTE>
<UL>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">Allow user to
	interactively retitle a window, v. useful when there are lots of
	fmap windows on a screen. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE>Prevent users from zooming in/out to the point where
	the drawing code breaks, particularly for zooming in where lines
	start to randomly appear/disappear. 
	</BLOCKQUOTE>
</UL>
<H1 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Design</H1>
<H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Overview</H2>
<H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Layering</H2>
<BLOCKQUOTE>The code has been arranged in layers, explicit function
calls (i.e. calls made by coding the name of the function rather than
by using a pointer to a function) are allowed to layers below but <B>NOT</B>
to layers above. This is paramount in maintaining the independence of
layers from one another. Calls can only be made to layers above via
the callback function mechanism. 
</BLOCKQUOTE>
<BLOCKQUOTE>Here is an attempt to capture the layering in ZMap, of
course it will go out of date rapidly but it provides an overview at
least: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">zmapApp                                   zmapManager                     zmapControl
=======                                   ===========                     ===========

createAppContext()        ---------&gt;   zMapManagerCreate()


removeZmapRow()           &lt;---cb----   removeZmapEntry()


                                       zMapManagerAdd()     ---------&gt;    zMapCreate()
                                       zMapManagerReset()   ---------&gt;    zMapReset()
                                       zMapManagerKill()    ---------&gt;    zMapDestroy()

                                       zmapDestroyedCB()    &lt;---cb----    killZMap()




                      contd from above..........


zmapControl                 zmapView
===========                 ========

zMapCreate()   --------&gt;  zMapViewCreate()
                          zMapViewConnect()

zmapControlLoadCB()
               --------&gt;  zMapViewConnect()
                          zMapViewLoad()

zmapControlResetCB()
               --------&gt;  zMapViewReset()


killViews()    --------&gt;  zMapViewDestroy()


viewKilledCB() &lt;---cb---  checkConnections()</PRE><H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">
Documentation</H2>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Source
Code docs</H3>
<BLOCKQUOTE>We are using the <A HREF="www.doxygen.org/index.html">doxygen
package</A> for documenting our source code. This seems to work well
and does just about everything we need, it builds and improves on the
DOC++ package which seems to no longer be under active development. 
</BLOCKQUOTE>
<BLOCKQUOTE>Some notes about using doxygen: 
</BLOCKQUOTE>
<UL>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">doxygen looks for C
	comment blocks that start with &quot; <B>/*!</B> &quot;. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE>For C language files it is imperative that you
	include either a &quot; <B>/*! \file */</B> &quot; or &quot; <B>/*!
	@defgroup</B> &quot; special comment in each file to be documented
	otherwise doxygen will <B>not</B> process the other comments in the
	file. 
	</BLOCKQUOTE>
</UL>
<BLOCKQUOTE>A suggested standard is that for each package within ZMap
(e.g. zmapConfig) the external interface functions are documented in
the source files where they occur and the external typedefs etc. are
documented in the public header for the package. This has the
advantage that all the comments are next to the code that would be
editted if the interface has to be changed, i.e. function comments
are next to the functions, typedef comments are next to the typedefs
and so on. 
</BLOCKQUOTE>
<BLOCKQUOTE>For an example of this see the documentation of the
zmapConfig code in <B>include/ZMap/zmapConfig.h</B> and
<B>zmapConfig/zmapConfig.c</B>. Note the use of the &quot; <B>/*!
@addtogroup</B> &quot; directive to add the <B>include/ZMap/zmapConfig.h</B>
documentation to that in <B>zmapConfig/zmapConfig.c</B>. 
</BLOCKQUOTE>
<H2 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Configuration
Files</H2>
<BLOCKQUOTE>The Lexical Scanner package within GLib is used to read
and write configuration files. The package requires a fair bit of
work from the applications side to process stanzas and so on but
using it has the advantage that we do not need to link in any further
libraries. We could for instance have used the libgnome gnome-config
calls, (see:
http://developer.gnome.org/doc/API/2.0/libgnome/libgnome-gnome-config.html)
but this would have required linking in the whole of the gnome
application stuff). 
</BLOCKQUOTE>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Memory
usage</H3>
<BLOCKQUOTE>An experiment with creating rectangles in a gnome canvas
showed that memory overhead is quite high. The upshot is that each
canvas_item rectangle costs about 2600 bytes, this is probably
because each one is represented by a GObject. 
</BLOCKQUOTE>
<BLOCKQUOTE>You can see a plot of this data by running gnuplot and
displaying the file gnome_canvas_mem_usage from this docs directory. 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">&gt; gnuplot
gnuplot&gt; plot &quot;gnome_canvas_mem_usage&quot;</PRE><H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">
Meeting Notes - Friday, 7th Feb, 2004</H3>
<BLOCKQUOTE>Rob has made some progress determining what the Zmap and
Fmap graph calls do and how to replace them with gtk calls, etc. The
only relevant calls seem to be box, text and line, though there was
one fmap circle call. This should be fine. He has created a zmap
which uses gnomecanvas for the navigator and scrollable windows.
There are issues with the scale bars which need to be addressed and
there are numerous graph calls still included which need to be
removed. 
</BLOCKQUOTE>
<BLOCKQUOTE>He also has a noddy application with a nice-looking scale
bar with coordinates and a feature consisting of two boxes joined by
a bent line which also uses the canvas. This is a useful application
for prototyping aspects of the project. Ed has done lots of work on
threading and now has an application which has a single thread
running a rather thin manager with multiple Zmaps, each of which will
issue a DB thread to handle data manipulation. 
</BLOCKQUOTE>
<BLOCKQUOTE>He returned from sunnier climes with a DAS2 server
application which we hope to get set up so we can do some work using
that as well as AceDB as our data source. He also has ExPat and
libcurl libraries which do SAX simple Access and gzip and zlib which
handle compression. 
</BLOCKQUOTE>
<BLOCKQUOTE>Apparently this means our http can have &lt;stag&gt;
content &lt;etag&gt; and our start callback routine will get called
when it encounters the stag, the content routine gets called for the
content and the end routine gets called for the etag. 
</BLOCKQUOTE>
<H3 STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0cm">Decisions</H3>
<OL>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">We decided that when the
	user hits the Split button it will just be the currently active
	window that is split, as in emacs, although the windows themselves
	will be held as a linked list at root level, so there won't be a
	hierarchy of windows in the application; they'll all have the same
	status. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">There must be an
	arbitrary minimum size window which we'll allow to split, and beyond
	that the Split button will be greyed out. This will be controlled by
	some publicised macro I think. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">We will only allow one
	sequence per Zmap. If they want another sequence, they'll have to
	run another Zmap. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE>We will retain the concept of three levels of
	scrolling. The main sequence will show as some sort of slider bar
	covering the entire height of the navigation panel. This can be
	thought of as range 'a'. The user can scroll within this area but
	the display won't change until buttonup, at which point the lights
	will dim. While moving the scroll bar, a little window should show
	the current coordinate, so they know where they are in the scroll. 
	</BLOCKQUOTE>
	<BLOCKQUOTE>Within that is the sequence which has been calculated,
	roughly 3 times the amount that can be displayed in the window. This
	is currently shown as a light grey area within the navigation panel
	and can be thought of as range 'b'. 
	</BLOCKQUOTE>
	<BLOCKQUOTE>We're thinking of adding a small scroll bar to this
	greyed are to allow the user to scroll within the calculated part of
	the sequence. We'd need to add extra scroll bars as the user split
	the screen, one per window. The handle would indicate roughly where
	in area 'b' the window display 'c' would be. Ed thinks recalculating
	this area as we scroll would be time-consuming, so we'd have to just
	redo it on buttonup, but I'm not convinced yet. If he's right, we'll
	need a little window showing the current coordinate for each 'c'
	window. 
	</BLOCKQUOTE>
	<BLOCKQUOTE STYLE="margin-bottom: 0cm">Finally, there is the range
	actually on display, range 'c'. This is scrolled with the current
	scrolled window scrollbars and the display scrolls as you do it. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE STYLE="margin-bottom: 0cm">We'll need drag bars on
	the top and bottom of the calculated area b, so the user can stretch
	it, and the code must supplement the SEGS array rather than
	recalculate it from scratch. 
	</BLOCKQUOTE>
	<LI><BLOCKQUOTE>When we calculate, we always calculate whole
	objects, so if a feature overlaps into the void, we include it in
	our calculated area, though we don't actually display it. When the
	user stretches the calculated area, we again calculate whole objects
	in both directions, then throw away duplicates, so we never have
	partial or duplicated objects. 
	</BLOCKQUOTE>
</OL>
<HR>
<H3>Column Controls</H3>
<P>Press the button, a list of <!--#include virtual="/perl/footer" -->
columns comes up, each with a check button.  Default is all on.  User
toggles the check buttons to control whether or not a column is
displayed.  On Dismiss, call flagColumnsByCheck() to set flags in the
ZmapWindow columns array of structures, then call showHideColumns()
to show or hide them.  Then call reOrderColumns() to shuffle the
visible ones up.</P>
<P>ShowHideColumns() will now be controlled by the ZmapWindow columns
array, rather than the mag factor in the types array, so we'll need a
flagColumnsByMag() function to set things up initially from the types
array.</P>
<P>ReOrderColumns() should use the ZmapFeatureType column_order
variable to determine the order of the columns.  A single int should
be fine for both forward and reverse strands.</P>
<P>I started to do this 08/12/04 but we decided there were higher
priority tasks, so I'm abandoning it for now.</P>
</BODY>
</HTML>