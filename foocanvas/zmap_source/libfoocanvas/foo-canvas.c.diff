--- ./merged_foocanvas/libfoocanvas/foo-canvas.c	2010-03-09 10:49:06.614000000 +0000
+++ ./zmap_foocanvas/libfoocanvas/foo-canvas.c	2010-03-04 16:31:44.000000000 +0000
@@ -75,7 +75,7 @@
 
 static void foo_canvas_request_update (FooCanvas      *canvas);
 static void group_add                   (FooCanvasGroup *group,
-					 FooCanvasItem  *item);
+					 FooCanvasItem  *item, FooCanvasGroupPosition position);
 static void group_remove                (FooCanvasGroup *group,
 					 FooCanvasItem  *item);
 static void redraw_and_repick_if_mapped (FooCanvasItem *item);
@@ -187,13 +187,52 @@
 }
 
 
+/**
+ * foo_canvas_item_new_position:
+ * @parent: The parent group for the new item.
+ * @type: The object type of the item.
+ * @position: puts new item at bottom (FOO_CANVAS_GROUP_BOTTOM) or top (FOO_CANVAS_GROUP_TOP)
+ * of parents stack of child items.
+ * @first_arg_name: A list of object argument name/value pairs, NULL-terminated,
+ * used to configure the item.  For example, "fill_color", "black",
+ * "width_units", 5.0, NULL.
+ * @Varargs:
+ *
+ * Creates a new canvas item with @parent as its parent group.  The item is
+ * created at the top of its parent's stack, and starts up as visible.  The item
+ * is of the specified @type, for example, it can be
+ * foo_canvas_rect_get_type().  The list of object arguments/value pairs is
+ * used to configure the item.
+ *
+ * Return value: The newly-created item.
+ **/
+FooCanvasItem *
+foo_canvas_item_new_position (FooCanvasGroup *parent, GType type, FooCanvasGroupPosition position,
+			      const gchar *first_arg_name, ...)
+{
+	FooCanvasItem *item;
+	va_list args;
+
+	g_return_val_if_fail (FOO_IS_CANVAS_GROUP (parent), NULL);
+	g_return_val_if_fail (g_type_is_a (type, foo_canvas_item_get_type ()), NULL);
+
+	item = FOO_CANVAS_ITEM (g_object_new (type, NULL));
+
+	va_start (args, first_arg_name);
+	foo_canvas_item_construct_position (item, parent, position, first_arg_name, args);
+	va_end (args);
+
+	return item;
+}
+
+
 /* Performs post-creation operations on a canvas item (adding it to its parent
  * group, etc.)
  */
 static void
-item_post_create_setup (FooCanvasItem *item)
+item_post_create_setup (FooCanvasItem *item, FooCanvasGroupPosition position)
 {
-	group_add (FOO_CANVAS_GROUP (item->parent), item);
+	group_add (FOO_CANVAS_GROUP (item->parent), item, position);
 
 	redraw_and_repick_if_mapped (item);
 }
@@ -217,7 +256,7 @@
 		} else if (g_value_get_object (value)) {
 			item->parent = FOO_CANVAS_ITEM (g_value_get_object (value));
 			item->canvas = item->parent->canvas;
-			item_post_create_setup (item);
+			item_post_create_setup (item, FOO_CANVAS_GROUP_TOP);
 		}
 		break;
 	case ITEM_PROP_VISIBLE:
@@ -275,7 +314,34 @@
 
 	g_object_set_valist (G_OBJECT (item), first_arg_name, args);
 
-	item_post_create_setup (item);
+	item_post_create_setup (item, FOO_CANVAS_GROUP_TOP);
+}
+
+
+/**
+ * foo_canvas_item_construct_position:
+ * @item: An unconstructed canvas item.
+ * @parent: The parent group for the item.
+ * @position: puts new item at bottom (FOO_CANVAS_GROUP_BOTTOM) or top (FOO_CANVAS_GROUP_TOP)
+ * of parents stack of child items.
+ * @first_arg_name: The name of the first argument for configuring the item.
+ * @args: The list of arguments used to configure the item.
+ *
+ * Constructs a canvas item; meant for use only by item implementations.
+ **/
+void
+foo_canvas_item_construct_position (FooCanvasItem *item, FooCanvasGroup *parent, FooCanvasGroupPosition position,
+				    const gchar *first_arg_name, va_list args)
+{
+	g_return_if_fail (FOO_IS_CANVAS_GROUP (parent));
+	g_return_if_fail (FOO_IS_CANVAS_ITEM (item));
+
+	item->parent = FOO_CANVAS_ITEM (parent);
+	item->canvas = item->parent->canvas;
+
+	g_object_set_valist (G_OBJECT (item), first_arg_name, args);
+
+	item_post_create_setup (item, position);
 }
 
 
@@ -985,7 +1051,7 @@
 	group_remove (FOO_CANVAS_GROUP (item->parent), item);
 	item->parent = FOO_CANVAS_ITEM (new_group);
 	/* item->canvas is unchanged.  */
-	group_add (new_group, item);
+	group_add (new_group, item, FOO_CANVAS_GROUP_TOP);
 
 	/* Redraw and repick */
 
@@ -1372,6 +1438,7 @@
 	bbox_x1 = 0;
 	bbox_y1 = 0;
 
+       if(item->object.flags & FOO_CANVAS_ITEM_VISIBLE){ 
 	for (list = group->item_list; list; list = list->next) {
 		i = list->data;
 
@@ -1390,6 +1457,7 @@
 			bbox_y1 = MAX (bbox_y1, i->y2);
 		}
 	}
+       }
 	item->x1 = bbox_x0;
 	item->y1 = bbox_y0;
 	item->x2 = bbox_x1;
@@ -1536,10 +1604,10 @@
 			has_point = TRUE;
 		} else
 			has_point = FALSE;
-
+		/* guessing that the x factor is OK here. RNGC */
 		if (has_point
 		    && point_item
-		    && ((int) (dist * item->canvas->pixels_per_unit + 0.5)
+		    && ((int) (dist * item->canvas->pixels_per_unit_x + 0.5)
 			<= item->canvas->close_enough)) {
 			best = dist;
 			*actual_item = point_item;
@@ -1638,7 +1706,7 @@
 
 /* Adds an item to a group */
 static void
-group_add (FooCanvasGroup *group, FooCanvasItem *item)
+group_add (FooCanvasGroup *group, FooCanvasItem *item, FooCanvasGroupPosition position)
 {
 #if GLIB_CHECK_VERSION(2,10,0) && GTK_CHECK_VERSION(2,8,14)
 	g_object_ref_sink (item);
@@ -1647,11 +1715,22 @@
 	gtk_object_sink (GTK_OBJECT (item));
 #endif
 
-	if (!group->item_list) {
-		group->item_list = g_list_append (group->item_list, item);
-		group->item_list_end = group->item_list;
-	} else
-		group->item_list_end = g_list_append (group->item_list_end, item)->next;
+	if (position == FOO_CANVAS_GROUP_TOP)
+	  {
+	    if (!group->item_list) {
+	      group->item_list = g_list_append (group->item_list, item);
+	      group->item_list_end = group->item_list;
+	    } else
+	      group->item_list_end = g_list_append (group->item_list_end, item)->next;
+	  }
+	else
+	  {
+	    if (!group->item_list) {
+	      group->item_list = g_list_prepend (group->item_list, item);
+	      group->item_list_end = group->item_list;
+	    } else
+	      group->item_list = g_list_prepend (group->item_list, item);
+	  }
 
 	if (item->object.flags & FOO_CANVAS_ITEM_VISIBLE &&
 	    group->item.object.flags & FOO_CANVAS_ITEM_MAPPED) {
@@ -1703,6 +1782,9 @@
 
 enum {
 	DRAW_BACKGROUND,
+	DRAWN_ITEMS,
+	BEGIN_UPDATE,
+	END_UPDATE,
 	LAST_SIGNAL
 };
 
@@ -2053,6 +2135,35 @@
 			      G_TYPE_NONE, 4, 
 			      G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
 
+	canvas_signals[DRAWN_ITEMS] =
+		g_signal_new ("drawn_items",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__INT_INT_INT_INT,
+			      G_TYPE_NONE, 4, 
+			      G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
+
+	canvas_signals[BEGIN_UPDATE] =
+		g_signal_new ("begin_update",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0); 
+
+	canvas_signals[END_UPDATE] =
+		g_signal_new ("end_update",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0); 
+
+
 	atk_registry_set_factory_type (atk_get_default_registry (),
 				       FOO_TYPE_CANVAS,
 				       foo_canvas_accessible_factory_get_type ());
@@ -2080,7 +2191,8 @@
 	canvas->scroll_x2 = canvas->layout.width;
 	canvas->scroll_y2 = canvas->layout.height;
 
-	canvas->pixels_per_unit = 1.0;
+	canvas->pixels_per_unit_x = 1.0;
+	canvas->pixels_per_unit_y = 1.0;
 
 	canvas->pick_event.type = GDK_LEAVE_NOTIFY;
 	canvas->pick_event.crossing.x = 0;
@@ -2305,8 +2417,8 @@
 	canvas_width = GTK_WIDGET (canvas)->allocation.width;
 	canvas_height = GTK_WIDGET (canvas)->allocation.height;
 
-	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit + 0.5);
-	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit + 0.5);
+	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit_x + 0.5);
+	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit_y + 0.5);
 
 	right_limit = scroll_width - canvas_width;
 	bottom_limit = scroll_height - canvas_height;
@@ -2873,6 +2985,8 @@
 	if (canvas->need_update) {
 		g_return_val_if_fail (!canvas->doing_update, FALSE);
 
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[BEGIN_UPDATE], 0);
+
 		canvas->doing_update = TRUE;
 		foo_canvas_item_invoke_update (canvas->root, 0, 0, 0);
 
@@ -2881,6 +2995,8 @@
 		canvas->doing_update = FALSE;
 
 		canvas->need_update = FALSE;
+
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[END_UPDATE], 0);
 	}
 
 	/* Hmmm. Would like to queue antiexposes if the update marked
@@ -2901,6 +3017,10 @@
 	/* Chain up to get exposes on child widgets */
 	GTK_WIDGET_CLASS (canvas_parent_class)->expose_event (widget, event);
 
+	g_signal_emit (G_OBJECT (canvas), canvas_signals[DRAWN_ITEMS], 0, 
+		       event->area.x, event->area.y,
+		       event->area.width, event->area.height);
+
 	return FALSE;
 }
 
@@ -2927,6 +3047,8 @@
 	if (canvas->need_update) {
 		g_return_if_fail (!canvas->doing_update);
 
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[BEGIN_UPDATE], 0);
+
 		canvas->doing_update = TRUE;
 		foo_canvas_item_invoke_update (canvas->root, 0, 0, 0);
 
@@ -2935,6 +3057,8 @@
 		canvas->doing_update = FALSE;
 
 		canvas->need_update = FALSE;
+
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[END_UPDATE], 0);
 	}
 
 	/* Pick new current item */
@@ -3029,7 +3153,7 @@
 	    (canvas->scroll_x2 == x2) && (canvas->scroll_y2 == y2)) {
 		return;
 	}
-	
+
 	/*
 	 * Set the new scrolling region.  If possible, do not move the visible contents of the
 	 * canvas.
@@ -3109,10 +3233,30 @@
  *
  * Sets the zooming factor of a canvas by specifying the number of pixels that
  * correspond to one canvas unit.
+ * This is retained for backwards compatibility and just calls
+ * foo_canvas_set_pixels_per_unit_xy, passing the number of pixels/unit twice.
  **/
 void
 foo_canvas_set_pixels_per_unit (FooCanvas *canvas, double n)
 {
+  foo_canvas_set_pixels_per_unit_xy(canvas, n, n);
+  return;
+}
+
+
+/**
+ * foo_canvas_set_pixels_per_unit_xy:
+ * @canvas: A canvas.
+ * @x: The number of pixels that correspond to one canvas unit on the x axis.
+ * @y: The number of pixels that correspond to one canvas unit on the y axis.
+ *
+ * Sets the zooming factor of a canvas by specifying the number of pixels that
+ * correspond to one canvas unit.
+ * Having two zooming factors enables asymmetric zooming.
+ **/
+void
+foo_canvas_set_pixels_per_unit_xy (FooCanvas *canvas, double x, double y)
+{
 	GtkWidget *widget;
 	double cx, cy;
 	int x1, y1;
@@ -3122,7 +3266,8 @@
 	gint attributes_mask;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
-	g_return_if_fail (n > FOO_CANVAS_EPSILON);
+	/* guessing that the x factor is OK here.  RNCG */
+	g_return_if_fail (x > FOO_CANVAS_EPSILON);
 
 	widget = GTK_WIDGET (canvas);
 
@@ -3130,14 +3275,15 @@
 	center_y = widget->allocation.height / 2;
 
 	/* Find the coordinates of the screen center in units. */
-	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit + canvas->scroll_x1 + canvas->zoom_xofs;
-	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit + canvas->scroll_y1 + canvas->zoom_yofs;
+	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit_x + canvas->scroll_x1 + canvas->zoom_xofs;
+	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit_y + canvas->scroll_y1 + canvas->zoom_yofs;
 
 	/* Now calculate the new offset of the upper left corner. (round not truncate) */
-	x1 = ((cx - canvas->scroll_x1) * n) - center_x + .5;
-	y1 = ((cy - canvas->scroll_y1) * n) - center_y + .5;
+	x1 = ((cx - canvas->scroll_x1) * x) - center_x + .5;
+	y1 = ((cy - canvas->scroll_y1) * y) - center_y + .5;
 
-	canvas->pixels_per_unit = n;
+	canvas->pixels_per_unit_x = x;
+	canvas->pixels_per_unit_y = y;
 
 	if (!(canvas->root->object.flags & FOO_CANVAS_ITEM_NEED_DEEP_UPDATE)) {
 		canvas->root->object.flags |= FOO_CANVAS_ITEM_NEED_DEEP_UPDATE;
@@ -3271,7 +3417,8 @@
 	foo_canvas_w2c (canvas, x, y, &cx, &cy);
 
 	dist = foo_canvas_item_invoke_point (canvas->root, x, y, cx, cy, &item);
-	if ((int) (dist * canvas->pixels_per_unit + 0.5) <= canvas->close_enough)
+	/* guessing the x factor is OK here.  RNGC */
+	if ((int) (dist * canvas->pixels_per_unit_x + 0.5) <= canvas->close_enough)
 		return item;
 	else
 		return NULL;
@@ -3334,16 +3481,17 @@
 void
 foo_canvas_w2c (FooCanvas *canvas, double wx, double wy, int *cx, int *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 	
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = floor ((wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs + 0.5);
+		*cx = floor ((wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs + 0.5);
 	if (cy)
-		*cy = floor ((wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs + 0.5);
+		*cy = floor ((wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs + 0.5);
 }
 
 /**
@@ -3383,16 +3531,17 @@
 void
 foo_canvas_w2c_d (FooCanvas *canvas, double wx, double wy, double *cx, double *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = (wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs;
+		*cx = (wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs;
 	if (cy)
-		*cy = (wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs;
+		*cy = (wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs;
 }
 
 
@@ -3409,16 +3558,17 @@
 void
 foo_canvas_c2w (FooCanvas *canvas, int cx, int cy, double *wx, double *wy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (wx)
-		*wx = (cx - canvas->zoom_xofs)/zoom + canvas->scroll_x1;
+		*wx = (cx - canvas->zoom_xofs)/zoom_x + canvas->scroll_x1;
 	if (wy)
-		*wy = (cy - canvas->zoom_yofs)/zoom + canvas->scroll_y1;
+		*wy = (cy - canvas->zoom_yofs)/zoom_y + canvas->scroll_y1;
 }
 
 
@@ -3444,11 +3594,11 @@
 
 	if (worldx)
 		*worldx = canvas->scroll_x1 + ((winx - canvas->zoom_xofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_x);
 
 	if (worldy)
 		*worldy = canvas->scroll_y1 + ((winy - canvas->zoom_yofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_y);
 }
 
 
@@ -3471,10 +3621,10 @@
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
 	if (winx)
-		*winx = (canvas->pixels_per_unit)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
+		*winx = (canvas->pixels_per_unit_x)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
 
 	if (winy)
-		*winy = (canvas->pixels_per_unit)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
+		*winy = (canvas->pixels_per_unit_y)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
 }
 
 
@@ -3997,3 +4147,11 @@
                                        FOO_TYPE_CANVAS_ITEM,
                                        foo_canvas_item_accessible_factory_get_type ());
 }
+
+void 
+foo_canvas_zmap(void)
+{
+  /* do nothing */
+}
+
+/*  Last edited: Mar  4 16:31 2010 (edgrif) */
