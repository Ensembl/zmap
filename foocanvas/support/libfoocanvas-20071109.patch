Only in ./: aclocal.m4
diff -u -r ../foocanvas.latest/autogen.sh ./autogen.sh
--- ../foocanvas.latest/autogen.sh	2007-11-05 16:53:02.000000000 +0000
+++ ./autogen.sh	2007-11-05 16:53:03.000000000 +0000
@@ -41,5 +41,5 @@
   exit 1
 fi
 
-REQUIRED_AUTOMAKE_VERSION=1.5
+REQUIRED_AUTOMAKE_VERSION=1.9
 GNOME_DATADIR="$gnome_datadir" USE_GNOME2_MACROS=1 . $gnome_autogen
Only in ./: autom4te.cache
Only in ./: config.guess
Only in ./: config.h.in
Only in ./: config.sub
Only in ./: configure
diff -u -r ../foocanvas.latest/configure.in ./configure.in
--- ../foocanvas.latest/configure.in	2007-11-05 16:53:02.000000000 +0000
+++ ./configure.in	2007-11-05 16:53:03.000000000 +0000
@@ -3,7 +3,7 @@
 AC_CONFIG_SRCDIR([libfoocanvas/foo-canvas.c])
 
 AC_CONFIG_HEADERS([config.h])
-AM_INIT_AUTOMAKE([dist-bz2])
+AM_INIT_AUTOMAKE([])
 
 AM_MAINTAINER_MODE
 
Only in ./demos: Makefile.in
Only in ./: depcomp
Only in ./: gmon.out
Only in ./: gtk-doc.make
Only in ./: INSTALL
Only in ./: install-sh
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas.c ./libfoocanvas/foo-canvas.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas.c	2007-11-09 12:11:20.008557041 +0000
@@ -78,7 +78,7 @@
 
 static void foo_canvas_request_update (FooCanvas      *canvas);
 static void group_add                   (FooCanvasGroup *group,
-					 FooCanvasItem  *item);
+					 FooCanvasItem  *item, FooCanvasGroupPosition position);
 static void group_remove                (FooCanvasGroup *group,
 					 FooCanvasItem  *item);
 static void redraw_and_repick_if_mapped (FooCanvasItem *item);
@@ -190,17 +190,56 @@
 }
 
 
+/**
+ * foo_canvas_item_new:
+ * @parent: The parent group for the new item.
+ * @type: The object type of the item.
+ * @position: puts new item at bottom (FOO_CANVAS_GROUP_BOTTOM) or top (FOO_CANVAS_GROUP_TOP)
+ * of parents stack of child items.
+ * @first_arg_name: A list of object argument name/value pairs, NULL-terminated,
+ * used to configure the item.  For example, "fill_color", "black",
+ * "width_units", 5.0, NULL.
+ * @Varargs:
+ *
+ * Creates a new canvas item with @parent as its parent group.  The item is
+ * created at the top of its parent's stack, and starts up as visible.  The item
+ * is of the specified @type, for example, it can be
+ * foo_canvas_rect_get_type().  The list of object arguments/value pairs is
+ * used to configure the item.
+ *
+ * Return value: The newly-created item.
+ **/
+FooCanvasItem *
+foo_canvas_item_new_position (FooCanvasGroup *parent, GType type, FooCanvasGroupPosition position,
+			      const gchar *first_arg_name, ...)
+{
+	FooCanvasItem *item;
+	va_list args;
+
+	g_return_val_if_fail (FOO_IS_CANVAS_GROUP (parent), NULL);
+	g_return_val_if_fail (g_type_is_a (type, foo_canvas_item_get_type ()), NULL);
+
+	item = FOO_CANVAS_ITEM (g_object_new (type, NULL));
+
+	va_start (args, first_arg_name);
+	foo_canvas_item_construct_position (item, parent, position, first_arg_name, args);
+	va_end (args);
+
+	return item;
+}
+
+
 /* Performs post-creation operations on a canvas item (adding it to its parent
  * group, etc.)
  */
 static void
-item_post_create_setup (FooCanvasItem *item)
+item_post_create_setup (FooCanvasItem *item, FooCanvasGroupPosition position)
 {
 	GtkObject *obj;
 
 	obj = GTK_OBJECT (item);
 
-	group_add (FOO_CANVAS_GROUP (item->parent), item);
+	group_add (FOO_CANVAS_GROUP (item->parent), item, position);
 
 	redraw_and_repick_if_mapped (item);
 }
@@ -224,7 +263,7 @@
 		} else if (g_value_get_object (value)) {
 			item->parent = FOO_CANVAS_ITEM (g_value_get_object (value));
 			item->canvas = item->parent->canvas;
-			item_post_create_setup (item);
+			item_post_create_setup (item, FOO_CANVAS_GROUP_TOP);
 		}
 		break;
 	case ITEM_PROP_VISIBLE:
@@ -282,7 +321,34 @@
 
 	g_object_set_valist (G_OBJECT (item), first_arg_name, args);
 
-	item_post_create_setup (item);
+	item_post_create_setup (item, FOO_CANVAS_GROUP_TOP);
+}
+
+
+/**
+ * foo_canvas_item_construct_position:
+ * @item: An unconstructed canvas item.
+ * @parent: The parent group for the item.
+ * @position: puts new item at bottom (FOO_CANVAS_GROUP_BOTTOM) or top (FOO_CANVAS_GROUP_TOP)
+ * of parents stack of child items.
+ * @first_arg_name: The name of the first argument for configuring the item.
+ * @args: The list of arguments used to configure the item.
+ *
+ * Constructs a canvas item; meant for use only by item implementations.
+ **/
+void
+foo_canvas_item_construct_position (FooCanvasItem *item, FooCanvasGroup *parent, FooCanvasGroupPosition position,
+				    const gchar *first_arg_name, va_list args)
+{
+	g_return_if_fail (FOO_IS_CANVAS_GROUP (parent));
+	g_return_if_fail (FOO_IS_CANVAS_ITEM (item));
+
+	item->parent = FOO_CANVAS_ITEM (parent);
+	item->canvas = item->parent->canvas;
+
+	g_object_set_valist (G_OBJECT (item), first_arg_name, args);
+
+	item_post_create_setup (item, position);
 }
 
 
@@ -295,6 +361,7 @@
 	}
 }
 
+
 /* Destroy handler for canvas items */
 static void
 foo_canvas_item_destroy (GtkObject *object)
@@ -339,10 +406,8 @@
 
 		if (item->parent)
 			group_remove (FOO_CANVAS_GROUP (item->parent), item);
-
 		item->canvas = NULL;
 	}
-
 	GTK_OBJECT_CLASS (item_parent_class)->destroy (object);
 }
 
@@ -992,7 +1057,7 @@
 	group_remove (FOO_CANVAS_GROUP (item->parent), item);
 	item->parent = FOO_CANVAS_ITEM (new_group);
 	/* item->canvas is unchanged.  */
-	group_add (new_group, item);
+	group_add (new_group, item, FOO_CANVAS_GROUP_TOP);
 
 	/* Redraw and repick */
 
@@ -1376,6 +1441,7 @@
 	bbox_x1 = 0;
 	bbox_y1 = 0;
 
+       if(item->object.flags & FOO_CANVAS_ITEM_VISIBLE){ 
 	for (list = group->item_list; list; list = list->next) {
 		i = list->data;
 
@@ -1394,10 +1460,14 @@
 			bbox_y1 = MAX (bbox_y1, i->y2);
 		}
 	}
+
+       }
 	item->x1 = bbox_x0;
 	item->y1 = bbox_y0;
 	item->x2 = bbox_x1;
 	item->y2 = bbox_y1;
+
+        return ;
 }
 
 /* Unrealize handler for canvas groups */
@@ -1540,10 +1610,10 @@
 			has_point = TRUE;
 		} else
 			has_point = FALSE;
-
+		/* guessing that the x factor is OK here. RNGC */
 		if (has_point
 		    && point_item
-		    && ((int) (dist * item->canvas->pixels_per_unit + 0.5)
+		    && ((int) (dist * item->canvas->pixels_per_unit_x + 0.5)
 			<= item->canvas->close_enough)) {
 			best = dist;
 			*actual_item = point_item;
@@ -1553,7 +1623,7 @@
 	return best;
 }
 
-static void
+void
 foo_canvas_group_translate (FooCanvasItem *item, double dx, double dy)
 {
         FooCanvasGroup *group;
@@ -1642,16 +1712,30 @@
 
 /* Adds an item to a group */
 static void
-group_add (FooCanvasGroup *group, FooCanvasItem *item)
+group_add (FooCanvasGroup *group, FooCanvasItem *item, FooCanvasGroupPosition position)
 {
 	g_object_ref (GTK_OBJECT (item));
 	gtk_object_sink (GTK_OBJECT (item));
 
-	if (!group->item_list) {
-		group->item_list = g_list_append (group->item_list, item);
-		group->item_list_end = group->item_list;
-	} else
-		group->item_list_end = g_list_append (group->item_list_end, item)->next;
+	if (position == FOO_CANVAS_GROUP_TOP)
+	  {
+	    if (!group->item_list) {
+	      group->item_list = g_list_append (group->item_list, item);
+	      group->item_list_end = group->item_list;
+	    } else
+	      group->item_list_end = g_list_append (group->item_list_end, item)->next;
+	  }
+	else
+	  {
+	    if (!group->item_list) {
+	      group->item_list = g_list_prepend (group->item_list, item);
+	      group->item_list_end = group->item_list;
+	    } else
+	      group->item_list = g_list_prepend (group->item_list, item);
+	  }
+
+
+
 
 	if (item->object.flags & FOO_CANVAS_ITEM_VISIBLE &&
 	    group->item.object.flags & FOO_CANVAS_ITEM_MAPPED) {
@@ -1703,6 +1787,9 @@
 
 enum {
 	DRAW_BACKGROUND,
+	DRAWN_ITEMS,
+	BEGIN_UPDATE,
+	END_UPDATE,
 	LAST_SIGNAL
 };
 
@@ -2053,6 +2140,35 @@
 			      G_TYPE_NONE, 4, 
 			      G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
 
+	canvas_signals[DRAWN_ITEMS] =
+		g_signal_new ("drawn_items",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__INT_INT_INT_INT,
+			      G_TYPE_NONE, 4, 
+			      G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
+
+	canvas_signals[BEGIN_UPDATE] =
+		g_signal_new ("begin_update",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0); 
+
+	canvas_signals[END_UPDATE] =
+		g_signal_new ("end_update",
+			      G_TYPE_FROM_CLASS (object_class),
+			      G_SIGNAL_RUN_FIRST,
+			      0,
+			      NULL, NULL,
+			      foo_canvas_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0); 
+
+
 	atk_registry_set_factory_type (atk_get_default_registry (),
 				       FOO_TYPE_CANVAS,
 				       foo_canvas_accessible_factory_get_type ());
@@ -2080,7 +2196,8 @@
 	canvas->scroll_x2 = canvas->layout.width;
 	canvas->scroll_y2 = canvas->layout.height;
 
-	canvas->pixels_per_unit = 1.0;
+	canvas->pixels_per_unit_x = 1.0;
+	canvas->pixels_per_unit_y = 1.0;
 
 	canvas->pick_event.type = GDK_LEAVE_NOTIFY;
 	canvas->pick_event.crossing.x = 0;
@@ -2298,12 +2415,12 @@
 	int old_zoom_xofs, old_zoom_yofs;
 	int changed_x = FALSE, changed_y = FALSE;
 	int canvas_width, canvas_height;
-
+	
 	canvas_width = GTK_WIDGET (canvas)->allocation.width;
 	canvas_height = GTK_WIDGET (canvas)->allocation.height;
 
-	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit + 0.5);
-	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit + 0.5);
+	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit_x + 0.5);
+	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit_y + 0.5);
 
 	right_limit = scroll_width - canvas_width;
 	bottom_limit = scroll_height - canvas_height;
@@ -2867,10 +2984,14 @@
 		g_source_remove (canvas->idle_id);
 		canvas->idle_id = 0;
 	}
+
 	if (canvas->need_update) {
 		g_return_val_if_fail (!canvas->doing_update, FALSE);
 
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[BEGIN_UPDATE], 0);
+
 		canvas->doing_update = TRUE;
+
 		foo_canvas_item_invoke_update (canvas->root, 0, 0, 0);
 
 		g_return_val_if_fail (canvas->doing_update, FALSE);
@@ -2878,6 +2999,8 @@
 		canvas->doing_update = FALSE;
 
 		canvas->need_update = FALSE;
+
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[END_UPDATE], 0);
 	}
 
 	/* Hmmm. Would like to queue antiexposes if the update marked
@@ -2888,16 +3011,20 @@
 		       event->area.x, event->area.y,
 		       event->area.width, event->area.height);
 	
-	if (canvas->root->object.flags & FOO_CANVAS_ITEM_MAPPED)
+	if (canvas->root->object.flags & FOO_CANVAS_ITEM_MAPPED){
 		(* FOO_CANVAS_ITEM_GET_CLASS (canvas->root)->draw) (canvas->root,
-								      canvas->layout.bin_window,
-								      event);
-
+								    canvas->layout.bin_window,
+								    event);
+	}
 
 
 	/* Chain up to get exposes on child widgets */
 	GTK_WIDGET_CLASS (canvas_parent_class)->expose_event (widget, event);
 
+	g_signal_emit (G_OBJECT (canvas), canvas_signals[DRAWN_ITEMS], 0, 
+		       event->area.x, event->area.y,
+		       event->area.width, event->area.height);
+
 	return FALSE;
 }
 
@@ -2919,11 +3046,12 @@
 do_update (FooCanvas *canvas)
 {
 	/* Cause the update if necessary */
-
 update_again:
 	if (canvas->need_update) {
 		g_return_if_fail (!canvas->doing_update);
 
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[BEGIN_UPDATE], 0);
+
 		canvas->doing_update = TRUE;
 		foo_canvas_item_invoke_update (canvas->root, 0, 0, 0);
 
@@ -2932,6 +3060,8 @@
 		canvas->doing_update = FALSE;
 
 		canvas->need_update = FALSE;
+
+		g_signal_emit(G_OBJECT (canvas), canvas_signals[END_UPDATE], 0);
 	}
 
 	/* Pick new current item */
@@ -2949,6 +3079,8 @@
 	if (canvas->need_update) {
 		goto update_again;
 	}
+
+	return ;
 }
 
 /* Idle handler for the canvas.  It deals with pending updates and redraws. */
@@ -3026,7 +3158,7 @@
 	    (canvas->scroll_x2 == x2) && (canvas->scroll_y2 == y2)) {
 		return;
 	}
-	
+
 	/*
 	 * Set the new scrolling region.  If possible, do not move the visible contents of the
 	 * canvas.
@@ -3101,15 +3233,35 @@
 
 /**
  * foo_canvas_set_pixels_per_unit:
- * @canvas: A canvas.
+ * @canvas: A canvas
  * @n: The number of pixels that correspond to one canvas unit.
  *
  * Sets the zooming factor of a canvas by specifying the number of pixels that
  * correspond to one canvas unit.
+ * This is retained for backwards compatibility and just calls
+ * foo_canvas_set_pixels_per_unit_xy, passing the number of pixels/unit twice.
  **/
 void
 foo_canvas_set_pixels_per_unit (FooCanvas *canvas, double n)
 {
+  foo_canvas_set_pixels_per_unit_xy(canvas, n, n);
+  return;
+}
+
+
+/**
+ * foo_canvas_set_pixels_per_unit_xy:
+ * @canvas: A canvas.
+ * @x: The number of pixels that correspond to one canvas unit on the x axis.
+ * @y: The number of pixels that correspond to one canvas unit on the y axis.
+ *
+ * Sets the zooming factor of a canvas by specifying the number of pixels that
+ * correspond to one canvas unit.
+ * Having two zooming factors enables asymmetric zooming.
+ **/
+void
+foo_canvas_set_pixels_per_unit_xy (FooCanvas *canvas, double x, double y)
+{
 	GtkWidget *widget;
 	double cx, cy;
 	int x1, y1;
@@ -3119,7 +3271,8 @@
 	gint attributes_mask;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
-	g_return_if_fail (n > FOO_CANVAS_EPSILON);
+	/* guessing that the x factor is OK here.  RNCG */
+	g_return_if_fail (x > FOO_CANVAS_EPSILON);
 
 	widget = GTK_WIDGET (canvas);
 
@@ -3127,14 +3280,15 @@
 	center_y = widget->allocation.height / 2;
 
 	/* Find the coordinates of the screen center in units. */
-	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit + canvas->scroll_x1 + canvas->zoom_xofs;
-	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit + canvas->scroll_y1 + canvas->zoom_yofs;
+	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit_x + canvas->scroll_x1 + canvas->zoom_xofs;
+	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit_y + canvas->scroll_y1 + canvas->zoom_yofs;
 
 	/* Now calculate the new offset of the upper left corner. (round not truncate) */
-	x1 = ((cx - canvas->scroll_x1) * n) - center_x + .5;
-	y1 = ((cy - canvas->scroll_y1) * n) - center_y + .5;
+	x1 = ((cx - canvas->scroll_x1) * x) - center_x + .5;
+	y1 = ((cy - canvas->scroll_y1) * y) - center_y + .5;
 
-	canvas->pixels_per_unit = n;
+	canvas->pixels_per_unit_x = x;
+	canvas->pixels_per_unit_y = y;
 
 	if (!(canvas->root->object.flags & FOO_CANVAS_ITEM_NEED_DEEP_UPDATE)) {
 		canvas->root->object.flags |= FOO_CANVAS_ITEM_NEED_DEEP_UPDATE;
@@ -3268,7 +3422,8 @@
 	foo_canvas_w2c (canvas, x, y, &cx, &cy);
 
 	dist = foo_canvas_item_invoke_point (canvas->root, x, y, cx, cy, &item);
-	if ((int) (dist * canvas->pixels_per_unit + 0.5) <= canvas->close_enough)
+	/* guessing the x factor is OK here.  RNGC */
+	if ((int) (dist * canvas->pixels_per_unit_x + 0.5) <= canvas->close_enough)
 		return item;
 	else
 		return NULL;
@@ -3331,16 +3486,17 @@
 void
 foo_canvas_w2c (FooCanvas *canvas, double wx, double wy, int *cx, int *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 	
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = floor ((wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs + 0.5);
+		*cx = floor ((wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs + 0.5);
 	if (cy)
-		*cy = floor ((wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs + 0.5);
+		*cy = floor ((wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs + 0.5);
 }
 
 /**
@@ -3380,16 +3536,17 @@
 void
 foo_canvas_w2c_d (FooCanvas *canvas, double wx, double wy, double *cx, double *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = (wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs;
+		*cx = (wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs;
 	if (cy)
-		*cy = (wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs;
+		*cy = (wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs;
 }
 
 
@@ -3406,16 +3563,17 @@
 void
 foo_canvas_c2w (FooCanvas *canvas, int cx, int cy, double *wx, double *wy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (wx)
-		*wx = (cx - canvas->zoom_xofs)/zoom + canvas->scroll_x1;
+		*wx = (cx - canvas->zoom_xofs)/zoom_x + canvas->scroll_x1;
 	if (wy)
-		*wy = (cy - canvas->zoom_yofs)/zoom + canvas->scroll_y1;
+		*wy = (cy - canvas->zoom_yofs)/zoom_y + canvas->scroll_y1;
 }
 
 
@@ -3441,11 +3599,11 @@
 
 	if (worldx)
 		*worldx = canvas->scroll_x1 + ((winx - canvas->zoom_xofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_x);
 
 	if (worldy)
 		*worldy = canvas->scroll_y1 + ((winy - canvas->zoom_yofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_y);
 }
 
 
@@ -3468,10 +3626,10 @@
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
 	if (winx)
-		*winx = (canvas->pixels_per_unit)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
+		*winx = (canvas->pixels_per_unit_x)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
 
 	if (winy)
-		*winy = (canvas->pixels_per_unit)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
+		*winy = (canvas->pixels_per_unit_y)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
 }
 
 
@@ -3999,3 +4157,11 @@
                                        FOO_TYPE_CANVAS_ITEM,
                                        foo_canvas_item_accessible_factory_get_type ());
 }
+
+void 
+foo_canvas_zmap(void)
+{
+  /* do nothing */
+}
+
+/*  Last edited: Nov  9 12:11 2007 (rds) */
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas.h ./libfoocanvas/foo-canvas.h
--- ../foocanvas.latest/libfoocanvas/foo-canvas.h	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas.h	2007-11-09 10:56:04.895677663 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Nov  9 10:56 2007 (rds) */
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: 8; c-basic-offset: 8 -*- */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
@@ -101,6 +102,11 @@
 	FOO_CANVAS_UPDATE_DEEP       = 1 << 1
 };
 
+
+/* Special positions for putting new items at top or bottom of group. */
+typedef enum {FOO_CANVAS_GROUP_BOTTOM = -1, FOO_CANVAS_GROUP_TOP  = -2} FooCanvasGroupPosition ;
+
+
 #define FOO_TYPE_CANVAS_ITEM            (foo_canvas_item_get_type ())
 #define FOO_CANVAS_ITEM(obj)            (GTK_CHECK_CAST ((obj), FOO_TYPE_CANVAS_ITEM, FooCanvasItem))
 #define FOO_CANVAS_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), FOO_TYPE_CANVAS_ITEM, FooCanvasItemClass))
@@ -186,10 +192,16 @@
 FooCanvasItem *foo_canvas_item_new (FooCanvasGroup *parent, GType type,
 				    const gchar *first_arg_name, ...);
 
+FooCanvasItem *foo_canvas_item_new_position (FooCanvasGroup *parent, GType type, FooCanvasGroupPosition position,
+					     const gchar *first_arg_name, ...);
+
 /* Constructors for use in derived classes and language wrappers */
 void foo_canvas_item_construct (FooCanvasItem *item, FooCanvasGroup *parent,
 				const gchar *first_arg_name, va_list args);
 
+void foo_canvas_item_construct_position (FooCanvasItem *item, FooCanvasGroup *parent, FooCanvasGroupPosition position,
+					 const gchar *first_arg_name, va_list args);
+
 /* Configure an item using the standard Gtk argument mechanism.  The last
  * argument must be a NULL pointer.
  */
@@ -341,6 +353,7 @@
 #define FOO_IS_CANVAS_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), FOO_TYPE_CANVAS))
 #define FOO_CANVAS_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), FOO_TYPE_CANVAS, FooCanvasClass))
 
+typedef void (*FooCanvasUpdateSignal)(FooCanvas *canvas, gpointer user_data);
 
 struct _FooCanvas {
 	GtkLayout layout;
@@ -371,7 +384,8 @@
 	double scroll_x2, scroll_y2;
 
 	/* Scaling factor to be used for display */
-	double pixels_per_unit;
+	double pixels_per_unit_x;
+	double pixels_per_unit_y;
 
 	/* Idle handler ID */
 	guint idle_id;
@@ -456,6 +470,10 @@
 /* Sets the number of pixels that correspond to one unit in world coordinates */
 void foo_canvas_set_pixels_per_unit (FooCanvas *canvas, double n);
 
+/* Sets the number of  pixels corresponding to one unit in world coordinates
+ * separately on x and y axes, allowing asymmetric zooming. */
+void foo_canvas_set_pixels_per_unit_xy (FooCanvas *canvas, double x, double y);
+
 /* Wether the canvas centers the scroll region if it is smaller than the window  */
 void foo_canvas_set_center_scroll_region (FooCanvas *canvas, gboolean center_scroll_region);
 
@@ -525,6 +543,10 @@
  */
 void foo_canvas_set_stipple_origin (FooCanvas *canvas, GdkGC *gc);
 
+void foo_canvas_zmap(void);
+
 G_END_DECLS
 
+
 #endif
+
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-line.c ./libfoocanvas/foo-canvas-line.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-line.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-line.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Oct 18 18:34 2006 (rds) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -338,7 +339,7 @@
 	/* Add possible over-estimate for wide lines */
 
 	if (line->width_pixels)
-		width = line->width / line->item.canvas->pixels_per_unit;
+		width = line->width / line->item.canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
@@ -466,7 +467,7 @@
 		return;
 
 	if (line->width_pixels)
-		width = line->width / line->item.canvas->pixels_per_unit;
+		width = line->width / line->item.canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
@@ -477,9 +478,9 @@
 	shape_c = line->shape_c + width / 2.0;
 
 	if (line->width_pixels) {
-		shape_a /= line->item.canvas->pixels_per_unit;
-		shape_b /= line->item.canvas->pixels_per_unit;
-		shape_c /= line->item.canvas->pixels_per_unit;
+		shape_a /= line->item.canvas->pixels_per_unit_x;
+		shape_b /= line->item.canvas->pixels_per_unit_x;
+		shape_c /= line->item.canvas->pixels_per_unit_x;
 	}
 
 	shape_a += 0.001;
@@ -600,7 +601,7 @@
 	if (line->width_pixels)
 		width = (int) line->width;
 	else
-		width = (int) (line->width * line->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (line->width * line->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (line->gc,
 				    width,
@@ -1126,12 +1127,12 @@
 	 */
 
 	if (line->width_pixels)
-		width = line->width / item->canvas->pixels_per_unit;
+		width = line->width / item->canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
-	if (width < (1.0 / item->canvas->pixels_per_unit))
-		width = 1.0 / item->canvas->pixels_per_unit;
+	if (width < (1.0 / item->canvas->pixels_per_unit_x))
+		width = 1.0 / item->canvas->pixels_per_unit_x;
 
 	changed_miter_to_bevel = 0;
 
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-marshal.list ./libfoocanvas/foo-canvas-marshal.list
--- ../foocanvas.latest/libfoocanvas/foo-canvas-marshal.list	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-marshal.list	2007-11-09 11:11:00.397948830 +0000
@@ -1,2 +1,3 @@
 VOID:INT,INT,INT,INT
 BOOLEAN:BOXED
+VOID:VOID
Only in ./libfoocanvas: foo-canvas-marshal.list~
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-pixbuf.c ./libfoocanvas/foo-canvas-pixbuf.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-pixbuf.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-pixbuf.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: May 11 11:33 2004 (rnc) */
 /* GNOME libraries - GdkPixbuf item for the GNOME canvas
  *
  * Copyright (C) 1999 The Free Software Foundation
@@ -564,13 +565,13 @@
 	}
 
 	if (priv->x_in_pixels) {
-		x = i2w_dx + priv->x / item->canvas->pixels_per_unit;
+		x = i2w_dx + priv->x / item->canvas->pixels_per_unit_x;
 	} else {
 		x = i2w_dx + priv->x;
 	}
 
 	if (priv->y_in_pixels) {
-		y = i2w_dy + priv->y / item->canvas->pixels_per_unit;
+		y = i2w_dy + priv->y / item->canvas->pixels_per_unit_y;
 	} else {
 		y = i2w_dy + priv->y;
 	}
@@ -582,7 +583,7 @@
 	}
 
 	if (priv->width_in_pixels)
-		width /= item->canvas->pixels_per_unit;
+		width /= item->canvas->pixels_per_unit_x;
 
 	if (priv->height_set) {
 		height = priv->height;
@@ -591,7 +592,7 @@
 	}
 
 	if (priv->height_in_pixels)
-		height /= item->canvas->pixels_per_unit;
+		height /= item->canvas->pixels_per_unit_y;
 
 
 	switch (priv->anchor) {
@@ -781,8 +782,8 @@
 	pixbuf = priv->pixbuf;
 
 	*actual_item = item;
-
-	no_hit = item->canvas->pixels_per_unit * 2 + 10;
+	/* guessing that the x factor is OK here. RNGC */
+	no_hit = item->canvas->pixels_per_unit_x * 2 + 10;
 
 	if (!priv->pixbuf)
 		return no_hit;
@@ -823,13 +824,13 @@
 	priv = gcp->priv;
 
 	if (priv->x_in_pixels) {
-		priv->x += dx * item->canvas->pixels_per_unit;
+		priv->x += dx * item->canvas->pixels_per_unit_x;
 	} else {
 		priv->x += dx;
 	}
 
 	if (priv->y_in_pixels) {
-		priv->y += dy * item->canvas->pixels_per_unit;
+		priv->y += dy * item->canvas->pixels_per_unit_y;
 	} else {
 		priv->y += dy;
 	}
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-polygon.c ./libfoocanvas/foo-canvas-polygon.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-polygon.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-polygon.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Oct 19 09:39 2006 (rds) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -276,7 +277,7 @@
 	/* Add outline width */
 
 	if (poly->width_pixels)
-		width = poly->width / poly->item.canvas->pixels_per_unit;
+		width = poly->width / poly->item.canvas->pixels_per_unit_x;
 	else
 		width = poly->width;
 
@@ -400,7 +401,7 @@
 	if (poly->width_pixels)
 		width = (int) poly->width;
 	else
-		width = (int) (poly->width * poly->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (poly->width * poly->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (poly->outline_gc, width,
 				    GDK_LINE_SOLID, GDK_CAP_ROUND, GDK_JOIN_ROUND);
@@ -595,15 +596,16 @@
 static void
 get_color_value (FooCanvasPolygon *poly, gulong pixel, GValue *value)
 {
-	GdkColor *color;
+	GdkColor color;
 	GdkColormap *colormap;
 
-	color = g_new (GdkColor, 1);
-	color->pixel = pixel;
+	//color = g_new (GdkColor, 1);
+	//color->pixel = pixel;
 
-	colormap = gtk_widget_get_colormap (GTK_WIDGET (poly));
-	gdk_rgb_find_color (colormap, color);
-	g_value_set_boxed (value, color);
+	colormap = gtk_widget_get_colormap (GTK_WIDGET (FOO_CANVAS_ITEM(poly)->canvas));
+	gdk_colormap_query_color(colormap, pixel, &color);
+	//gdk_rgb_find_color (colormap, color);
+	g_value_set_boxed (value, &color);
 }
 
 static void
@@ -801,7 +803,7 @@
 
 	if (poly->outline_set) {
 		if (poly->width_pixels)
-			width = poly->width / item->canvas->pixels_per_unit;
+			width = poly->width / item->canvas->pixels_per_unit_x;
 		else
 			width = poly->width;
 
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-rect-ellipse.c ./libfoocanvas/foo-canvas-rect-ellipse.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-rect-ellipse.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-rect-ellipse.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Feb 25 11:09 2005 (rds) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -281,7 +282,7 @@
 	item = FOO_CANVAS_ITEM (re);
 
 	if (re->width_pixels)
-		hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+		hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 	else
 		hwidth = re->width / 2.0;
 
@@ -352,7 +353,7 @@
 	if (re->width_pixels)
 		width = (int) re->width;
 	else
-		width = (int) (re->width * re->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (re->width * re->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (re->outline_gc, width,
 				    GDK_LINE_SOLID, GDK_CAP_PROJECTING, GDK_JOIN_MITER);
@@ -734,7 +735,7 @@
 	re = FOO_CANVAS_RE (item);
 
 	if (re->width_pixels)
-		hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+		hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 	else
 		hwidth = re->width / 2.0;
 
@@ -1065,7 +1066,7 @@
 
 	if (re->outline_set) {
 		if (re->width_pixels)
-			hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+			hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 		else
 			hwidth = re->width / 2.0;
 
@@ -1191,7 +1192,7 @@
 		if (re->width_pixels)
 			width_pixels = (int) re->width;
 		else
-			width_pixels = (int) floor (re->width * re->item.canvas->pixels_per_unit + 0.5);
+			width_pixels = (int) floor (re->width * re->item.canvas->pixels_per_unit_x + 0.5);
 
 		width_lt = width_pixels / 2;
 		width_rb = (width_pixels + 1) / 2;
@@ -1344,7 +1345,7 @@
 
 	if (re->outline_set) {
 		if (re->width_pixels)
-			width = re->width / item->canvas->pixels_per_unit;
+			width = re->width / item->canvas->pixels_per_unit_x;
 		else
 			width = re->width;
 	} else
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-text.c ./libfoocanvas/foo-canvas-text.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-text.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-text.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Oct 18 18:38 2006 (rds) */
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
 /*
  * $Id: foo-canvas-text.c 52 2005-04-04 15:13:29Z mortenw $
@@ -615,8 +616,8 @@
 	/* Get canvas pixel coordinates for clip rectangle position */
 
 	foo_canvas_w2c (item->canvas, wx, wy, &text->clip_cx, &text->clip_cy);
-	text->clip_cwidth = text->clip_width * item->canvas->pixels_per_unit;
-	text->clip_cheight = text->clip_height * item->canvas->pixels_per_unit;
+	text->clip_cwidth = text->clip_width * item->canvas->pixels_per_unit_x;
+	text->clip_cheight = text->clip_height * item->canvas->pixels_per_unit_y;
 
 	/* Anchor text */
 
@@ -976,7 +977,7 @@
 	case PROP_WRAP_WIDTH: {
 		double w = fabs (g_value_get_double (value));
 		pango_layout_set_width (text->layout,
-			w * text->item.canvas->pixels_per_unit * PANGO_SCALE);
+			w * text->item.canvas->pixels_per_unit_x * PANGO_SCALE);
 
 		break;
 	}
@@ -1252,11 +1253,11 @@
 		break;
 
 	case PROP_TEXT_WIDTH:
-		g_value_set_double (value, text->max_width / text->item.canvas->pixels_per_unit);
+		g_value_set_double (value, text->max_width / text->item.canvas->pixels_per_unit_x);
 		break;
 
 	case PROP_TEXT_HEIGHT:
-		g_value_set_double (value, text->height / text->item.canvas->pixels_per_unit);
+		g_value_set_double (value, text->height / text->item.canvas->pixels_per_unit_y);
 		break;
 
 	default:
@@ -1309,7 +1310,8 @@
 	if (text->rise_set)
 		add_attr (attr_list, pango_attr_rise_new (text->rise));
 
-	zoom = text->item.canvas->pixels_per_unit;
+	/* guessing that the x factor is OK here. RNGC */
+	zoom = text->item.canvas->pixels_per_unit_x;
 	if (fabs (zoom - 1.) > 1e-4) {
 		PangoAttribute *attr = pango_attr_scale_new (zoom);
 		attr->start_index = 0;
@@ -1479,14 +1481,14 @@
  	        PangoRectangle log_rect;
 
 		pango_layout_iter_get_line_extents (iter, NULL, &log_rect);
-
-		if (text->clip) {
+                /* if (text->clip) { // original */
+		/* if (!text->clip) { // broken for clipped !!! ;) */
+                if(1) {
 			x1 = PANGO_PIXELS (log_rect.x);
 			y1 = PANGO_PIXELS (log_rect.y);
 			x2 = PANGO_PIXELS (log_rect.x+log_rect.width);
 			y2 = PANGO_PIXELS (log_rect.y+log_rect.height);
 
-
 			if (x1 < text->clip_cx)
 				x1 = text->clip_cx;
 
@@ -1529,7 +1531,9 @@
 			return 0.0;
 		}
 
+
 		dist = sqrt (dx * dx + dy * dy);
+
 		if (dist < best)
 			best = dist;
 
@@ -1537,7 +1541,10 @@
 
 	pango_layout_iter_free(iter);
 
-	return best / item->canvas->pixels_per_unit;
+
+	/* guessing that the x factor is OK here. RNGC */
+        /* using x factor here as that is what is used in foo-canvas.c ... */
+	return best / item->canvas->pixels_per_unit_x;
 }
 
 static void
@@ -1567,8 +1574,8 @@
 		width = text->clip_width;
 		height = text->clip_height;
 	} else {
-		width = text->max_width / item->canvas->pixels_per_unit;
-		height = text->height / item->canvas->pixels_per_unit;
+		width = text->max_width / item->canvas->pixels_per_unit_x;
+		height = text->height / item->canvas->pixels_per_unit_y;
 	}
 
 	switch (text->anchor) {
diff -u -r ../foocanvas.latest/libfoocanvas/foo-canvas-widget.c ./libfoocanvas/foo-canvas-widget.c
--- ../foocanvas.latest/libfoocanvas/foo-canvas-widget.c	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/foo-canvas-widget.c	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: May 11 11:42 2004 (rnc) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -456,8 +457,8 @@
 			witem->cwidth = (int) (witem->width + 0.5);
 			witem->cheight = (int) (witem->height + 0.5);
 		} else {
-			witem->cwidth = (int) (witem->width * item->canvas->pixels_per_unit + 0.5);
-			witem->cheight = (int) (witem->height * item->canvas->pixels_per_unit + 0.5);
+			witem->cwidth = (int) (witem->width * item->canvas->pixels_per_unit_x + 0.5);
+			witem->cheight = (int) (witem->height * item->canvas->pixels_per_unit_y + 0.5);
 		}
 
 		gtk_widget_set_usize (witem->widget, witem->cwidth, witem->cheight);
@@ -516,8 +517,8 @@
 
 	foo_canvas_c2w (item->canvas, witem->cx, witem->cy, &x1, &y1);
 
-	x2 = x1 + (witem->cwidth - 1) / item->canvas->pixels_per_unit;
-	y2 = y1 + (witem->cheight - 1) / item->canvas->pixels_per_unit;
+	x2 = x1 + (witem->cwidth - 1) / item->canvas->pixels_per_unit_x;
+	y2 = y1 + (witem->cheight - 1) / item->canvas->pixels_per_unit_y;
 
 	/* Is point inside widget bounds? */
 
Only in ./libfoocanvas: foozmap-canvas-line-glyph.c
Only in ./libfoocanvas: foozmap-canvas-line-glyph.h
diff -u -r ../foocanvas.latest/libfoocanvas/libfoocanvas.h ./libfoocanvas/libfoocanvas.h
--- ../foocanvas.latest/libfoocanvas/libfoocanvas.h	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/libfoocanvas.h	2007-11-05 16:53:03.000000000 +0000
@@ -1,3 +1,4 @@
+/*  Last edited: Aug  1 11:42 2006 (edgrif) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -35,6 +36,9 @@
 #include <libfoocanvas/foo-canvas-rect-ellipse.h>
 #include <libfoocanvas/foo-canvas-util.h>
 
+#include <libfoocanvas/foozmap-canvas-line-glyph.h>
+
+
 G_BEGIN_DECLS
 
 GType foo_canvas_points_get_type (void);
diff -u -r ../foocanvas.latest/libfoocanvas/Makefile.am ./libfoocanvas/Makefile.am
--- ../foocanvas.latest/libfoocanvas/Makefile.am	2007-11-05 16:53:02.000000000 +0000
+++ ./libfoocanvas/Makefile.am	2007-11-05 16:53:03.000000000 +0000
@@ -22,6 +22,7 @@
 
 libfoocanvasinclude_HEADERS =			\
 	foo-canvas-line.h			\
+	foozmap-canvas-line-glyph.h		\
 	foo-canvas-pixbuf.h			\
 	foo-canvas-polygon.h			\
 	foo-canvas-rect-ellipse.h		\
@@ -36,6 +37,7 @@
 	foo-canvas-marshal.list			\
 	foo-canvas-i18n.h			\
 	foo-canvas-line.c			\
+	foozmap-canvas-line-glyph.c		\
 	foo-canvas-pixbuf.c			\
 	foo-canvas-polygon.c			\
 	foo-canvas-rect-ellipse.c		\
Only in ./libfoocanvas: Makefile.in
Only in ./: ltmain.sh
Only in ./: Makefile.in
Only in ./: missing
Only in ./: mkinstalldirs
Only in ./po: Makefile.in.in
Only in ./: www.bytefresh.com
