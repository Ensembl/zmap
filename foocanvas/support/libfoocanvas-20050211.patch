Only in .: .cvsignore
Only in /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/: CVS
Only in .: Makefile.am
Only in .: foo-canvas-i18n.h
diff -u ./foo-canvas-line.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-line.c
--- ./foo-canvas-line.c	Fri Mar 12 16:30:49 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-line.c	Thu May 13 15:36:19 2004
@@ -1,3 +1,4 @@
+/*  Last edited: May 11 10:57 2004 (rnc) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -338,7 +339,7 @@
 	/* Add possible over-estimate for wide lines */
 
 	if (line->width_pixels)
-		width = line->width / line->item.canvas->pixels_per_unit;
+		width = line->width / line->item.canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
@@ -466,7 +467,7 @@
 		return;
 
 	if (line->width_pixels)
-		width = line->width / line->item.canvas->pixels_per_unit;
+		width = line->width / line->item.canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
@@ -477,9 +478,9 @@
 	shape_c = line->shape_c + width / 2.0;
 
 	if (line->width_pixels) {
-		shape_a /= line->item.canvas->pixels_per_unit;
-		shape_b /= line->item.canvas->pixels_per_unit;
-		shape_c /= line->item.canvas->pixels_per_unit;
+		shape_a /= line->item.canvas->pixels_per_unit_x;
+		shape_b /= line->item.canvas->pixels_per_unit_x;
+		shape_c /= line->item.canvas->pixels_per_unit_x;
 	}
 
 	shape_a += 0.001;
@@ -600,7 +601,7 @@
 	if (line->width_pixels)
 		width = (int) line->width;
 	else
-		width = (int) (line->width * line->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (line->width * line->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (line->gc,
 				    width,
@@ -867,11 +868,11 @@
 		break;
 
 	case PROP_FILL_COLOR:
-		g_value_take_string (value,
-				     g_strdup_printf ("#%02x%02x%02x",
-						      line->fill_rgba >> 24,
-						      (line->fill_rgba >> 16) & 0xff,
-						      (line->fill_rgba >> 8) & 0xff));
+		//g_value_take_string (value,
+		//		     g_strdup_printf ("#%02x%02x%02x",
+		//				      line->fill_rgba >> 24,
+		//				      (line->fill_rgba >> 16) & 0xff,
+		//				      (line->fill_rgba >> 8) & 0xff));
 		break;
 
 	case PROP_FILL_COLOR_GDK: {
@@ -1126,12 +1127,12 @@
 	 */
 
 	if (line->width_pixels)
-		width = line->width / item->canvas->pixels_per_unit;
+		width = line->width / item->canvas->pixels_per_unit_x;
 	else
 		width = line->width;
 
-	if (width < (1.0 / item->canvas->pixels_per_unit))
-		width = 1.0 / item->canvas->pixels_per_unit;
+	if (width < (1.0 / item->canvas->pixels_per_unit_x))
+		width = 1.0 / item->canvas->pixels_per_unit_x;
 
 	changed_miter_to_bevel = 0;
 
Only in .: foo-canvas-line.h
Only in .: foo-canvas-marshal.list
diff -u ./foo-canvas-pixbuf.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-pixbuf.c
--- ./foo-canvas-pixbuf.c	Fri Apr 23 06:31:12 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-pixbuf.c	Thu May 13 15:36:21 2004
@@ -1,3 +1,4 @@
+/*  Last edited: May 11 11:33 2004 (rnc) */
 /* GNOME libraries - GdkPixbuf item for the GNOME canvas
  *
  * Copyright (C) 1999 The Free Software Foundation
@@ -564,13 +565,13 @@
 	}
 
 	if (priv->x_in_pixels) {
-		x = i2w_dx + priv->x / item->canvas->pixels_per_unit;
+		x = i2w_dx + priv->x / item->canvas->pixels_per_unit_x;
 	} else {
 		x = i2w_dx + priv->x;
 	}
 
 	if (priv->y_in_pixels) {
-		y = i2w_dy + priv->y / item->canvas->pixels_per_unit;
+		y = i2w_dy + priv->y / item->canvas->pixels_per_unit_y;
 	} else {
 		y = i2w_dy + priv->y;
 	}
@@ -582,7 +583,7 @@
 	}
 
 	if (priv->width_in_pixels)
-		width /= item->canvas->pixels_per_unit;
+		width /= item->canvas->pixels_per_unit_x;
 
 	if (priv->height_set) {
 		height = priv->height;
@@ -591,7 +592,7 @@
 	}
 
 	if (priv->height_in_pixels)
-		height /= item->canvas->pixels_per_unit;
+		height /= item->canvas->pixels_per_unit_y;
 
 
 	switch (priv->anchor) {
@@ -781,8 +782,8 @@
 	pixbuf = priv->pixbuf;
 
 	*actual_item = item;
-
-	no_hit = item->canvas->pixels_per_unit * 2 + 10;
+	/* guessing that the x factor is OK here. RNGC */
+	no_hit = item->canvas->pixels_per_unit_x * 2 + 10;
 
 	if (!priv->pixbuf)
 		return no_hit;
@@ -823,13 +824,13 @@
 	priv = gcp->priv;
 
 	if (priv->x_in_pixels) {
-		priv->x += dx * item->canvas->pixels_per_unit;
+		priv->x += dx * item->canvas->pixels_per_unit_x;
 	} else {
 		priv->x += dx;
 	}
 
 	if (priv->y_in_pixels) {
-		priv->y += dy * item->canvas->pixels_per_unit;
+		priv->y += dy * item->canvas->pixels_per_unit_y;
 	} else {
 		priv->y += dy;
 	}
Only in .: foo-canvas-pixbuf.h
diff -u ./foo-canvas-polygon.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-polygon.c
--- ./foo-canvas-polygon.c	Sat Dec  4 05:01:22 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-polygon.c	Fri Feb 11 16:45:52 2005
@@ -1,3 +1,4 @@
+/*  Last edited: Feb 11 16:45 2005 (rds) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -261,9 +262,9 @@
 	double width;
 	int i;
 
-	if (poly->num_points == 0)
-		return FALSE;
-
+ 	if (poly->num_points == 0)
+ 		return FALSE;
+        
 	/* Compute bounds of vertices */
 
 	x1 = x2 = poly->coords[0];
@@ -276,7 +277,7 @@
 	/* Add outline width */
 
 	if (poly->width_pixels)
-		width = poly->width / poly->item.canvas->pixels_per_unit;
+		width = poly->width / poly->item.canvas->pixels_per_unit_x;
 	else
 		width = poly->width;
 
@@ -293,7 +294,7 @@
 	*by1 = y1;
 	*bx2 = x2;
 	*by2 = y2;
-	return TRUE;
+        return TRUE;
 }
 
 /* Computes the bounding box of the polygon, in canvas coordinates.  Assumes that the number of points in the polygon is
@@ -309,8 +310,8 @@
 
 	item = FOO_CANVAS_ITEM (poly);
 
-	if (!get_bounds (poly, &bbox_x0, &bbox_y0, &bbox_x1, &bbox_y1))
-		return FALSE;
+	if(!get_bounds (poly, &bbox_x0, &bbox_y0, &bbox_x1, &bbox_y1))
+               return FALSE;
 
 	bbox_x0 += i2w_dx; 
 	bbox_y0 += i2w_dy; 
@@ -325,7 +326,7 @@
 	*by1 = bbox_y0 - 1;
 	*bx2 = bbox_x1 + 1;
 	*by2 = bbox_y1 + 1;
-	return TRUE;
+        return TRUE;
 }
 
 /* Sets the points of the polygon item to the specified ones.  If needed, it will add a point to
@@ -400,7 +401,7 @@
 	if (poly->width_pixels)
 		width = (int) poly->width;
 	else
-		width = (int) (poly->width * poly->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (poly->width * poly->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (poly->outline_gc, width,
 				    GDK_LINE_SOLID, GDK_CAP_ROUND, GDK_JOIN_ROUND);
@@ -679,8 +680,8 @@
 	set_stipple (poly->fill_gc, &poly->fill_stipple, poly->fill_stipple, TRUE);
 	set_stipple (poly->outline_gc, &poly->outline_stipple, poly->outline_stipple, TRUE);
 	
-	if (get_bounds_canvas (poly, &x1, &y1, &x2, &y2, i2w_dx, i2w_dy))
-		foo_canvas_update_bbox (item, x1, y1, x2, y2);
+	if(get_bounds_canvas (poly, &x1, &y1, &x2, &y2, i2w_dx, i2w_dy))
+               foo_canvas_update_bbox (item, x1, y1, x2, y2);
 }
 
 static void
@@ -801,7 +802,7 @@
 
 	if (poly->outline_set) {
 		if (poly->width_pixels)
-			width = poly->width / item->canvas->pixels_per_unit;
+			width = poly->width / item->canvas->pixels_per_unit_x;
 		else
 			width = poly->width;
 
Only in .: foo-canvas-polygon.h
diff -u ./foo-canvas-rect-ellipse.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-rect-ellipse.c
--- ./foo-canvas-rect-ellipse.c	Wed Jul 14 12:04:02 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-rect-ellipse.c	Fri Feb 11 16:27:50 2005
@@ -1,3 +1,4 @@
+/*  Last edited: Feb 11 16:27 2005 (rds) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -281,7 +282,7 @@
 	item = FOO_CANVAS_ITEM (re);
 
 	if (re->width_pixels)
-		hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+		hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 	else
 		hwidth = re->width / 2.0;
 
@@ -300,7 +301,7 @@
 	*py2 = cy2;
 
 	/* Some safety fudging */
-
+	
 	*px1 -= 2;
 	*py1 -= 2;
 	*px2 += 2;
@@ -352,7 +353,7 @@
 	if (re->width_pixels)
 		width = (int) re->width;
 	else
-		width = (int) (re->width * re->item.canvas->pixels_per_unit + 0.5);
+		width = (int) (re->width * re->item.canvas->pixels_per_unit_x + 0.5);
 
 	gdk_gc_set_line_attributes (re->outline_gc, width,
 				    GDK_LINE_SOLID, GDK_CAP_PROJECTING, GDK_JOIN_MITER);
@@ -734,7 +735,7 @@
 	re = FOO_CANVAS_RE (item);
 
 	if (re->width_pixels)
-		hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+		hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 	else
 		hwidth = re->width / 2.0;
 
@@ -981,7 +982,7 @@
 
 	foo_canvas_w2c (item->canvas, x1, y1, &cx1, &cy1);
 	foo_canvas_w2c (item->canvas, x2, y2, &cx2, &cy2);
-	
+
 	if (re->fill_set) {
 		if ((re->fill_color & 0xff) != 255) {
 			GdkRectangle *rectangles;
@@ -1065,7 +1066,7 @@
 
 	if (re->outline_set) {
 		if (re->width_pixels)
-			hwidth = (re->width / item->canvas->pixels_per_unit) / 2.0;
+			hwidth = (re->width / item->canvas->pixels_per_unit_x) / 2.0;
 		else
 			hwidth = re->width / 2.0;
 
@@ -1167,6 +1168,9 @@
 	foo_canvas_w2c (item->canvas, x1, y1, &cx1, &cy1);
 	foo_canvas_w2c (item->canvas, x2, y2, &cx2, &cy2);
 
+	if (cy1 >= cy2) foo_canvas_item_hide(item); 
+	else foo_canvas_item_show(item);
+
 	update_rect = make_rect (cx1, cy1, cx2+1, cy2+1);
 #if 0
 	foo_canvas_request_redraw (item->canvas,
@@ -1191,7 +1195,7 @@
 		if (re->width_pixels)
 			width_pixels = (int) re->width;
 		else
-			width_pixels = (int) floor (re->width * re->item.canvas->pixels_per_unit + 0.5);
+			width_pixels = (int) floor (re->width * re->item.canvas->pixels_per_unit_x + 0.5);
 
 		width_lt = width_pixels / 2;
 		width_rb = (width_pixels + 1) / 2;
@@ -1344,7 +1348,7 @@
 
 	if (re->outline_set) {
 		if (re->width_pixels)
-			width = re->width / item->canvas->pixels_per_unit;
+			width = re->width / item->canvas->pixels_per_unit_x;
 		else
 			width = re->width;
 	} else
Only in .: foo-canvas-rect-ellipse.h
diff -u ./foo-canvas-text.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-text.c
--- ./foo-canvas-text.c	Fri Apr 23 06:36:54 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-text.c	Thu May 13 15:36:25 2004
@@ -1,6 +1,7 @@
+/*  Last edited: May 11 11:41 2004 (rnc) */
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
 /*
- * $Id: foo-canvas-text.c,v 1.7 2004/04/23 05:36:54 jody Exp $
+ * $Id: foo-canvas-text.c,v 1.1 2004/05/13 14:36:25 rnc Exp $
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
  *
@@ -615,8 +616,8 @@
 	/* Get canvas pixel coordinates for clip rectangle position */
 
 	foo_canvas_w2c (item->canvas, wx, wy, &text->clip_cx, &text->clip_cy);
-	text->clip_cwidth = text->clip_width * item->canvas->pixels_per_unit;
-	text->clip_cheight = text->clip_height * item->canvas->pixels_per_unit;
+	text->clip_cwidth = text->clip_width * item->canvas->pixels_per_unit_x;
+	text->clip_cheight = text->clip_height * item->canvas->pixels_per_unit_y;
 
 	/* Anchor text */
 
@@ -976,7 +977,7 @@
 	case PROP_WRAP_WIDTH: {
 		double w = fabs (g_value_get_double (value));
 		pango_layout_set_width (text->layout,
-			w * text->item.canvas->pixels_per_unit * PANGO_SCALE);
+			w * text->item.canvas->pixels_per_unit_x * PANGO_SCALE);
 
 		break;
 	}
@@ -1227,11 +1228,11 @@
 		break;
 
 	case PROP_FILL_COLOR:
-                g_value_take_string (value,
-				     g_strdup_printf ("#%02x%02x%02x",
-						      text->rgba >> 24,
-						      (text->rgba >> 16) & 0xff,
-						      (text->rgba >> 8) & 0xff));
+                //g_value_take_string (value,
+		//		     g_strdup_printf ("#%02x%02x%02x",
+		//				      text->rgba >> 24,
+		//				      (text->rgba >> 16) & 0xff,
+		//				      (text->rgba >> 8) & 0xff));
 		break;
 
 	case PROP_FILL_COLOR_GDK: {
@@ -1252,11 +1253,11 @@
 		break;
 
 	case PROP_TEXT_WIDTH:
-		g_value_set_double (value, text->max_width / text->item.canvas->pixels_per_unit);
+		g_value_set_double (value, text->max_width / text->item.canvas->pixels_per_unit_x);
 		break;
 
 	case PROP_TEXT_HEIGHT:
-		g_value_set_double (value, text->height / text->item.canvas->pixels_per_unit);
+		g_value_set_double (value, text->height / text->item.canvas->pixels_per_unit_y);
 		break;
 
 	default:
@@ -1309,7 +1310,8 @@
 	if (text->rise_set)
 		add_attr (attr_list, pango_attr_rise_new (text->rise));
 
-	zoom = text->item.canvas->pixels_per_unit;
+	/* guessing that the x factor is OK here. RNGC */
+	zoom = text->item.canvas->pixels_per_unit_x;
 	if (fabs (zoom - 1.) > 1e-4) {
 		PangoAttribute *attr = pango_attr_scale_new (zoom);
 		attr->start_index = 0;
@@ -1537,7 +1539,8 @@
 
 	pango_layout_iter_free(iter);
 
-	return best / item->canvas->pixels_per_unit;
+	/* guessing that the x factor is OK here. RNGC */
+	return best / item->canvas->pixels_per_unit_x;
 }
 
 static void
@@ -1567,8 +1570,8 @@
 		width = text->clip_width;
 		height = text->clip_height;
 	} else {
-		width = text->max_width / item->canvas->pixels_per_unit;
-		height = text->height / item->canvas->pixels_per_unit;
+		width = text->max_width / item->canvas->pixels_per_unit_x;
+		height = text->height / item->canvas->pixels_per_unit_y;
 	}
 
 	switch (text->anchor) {
Only in .: foo-canvas-text.h
Only in .: foo-canvas-util.c
Only in .: foo-canvas-util.h
diff -u ./foo-canvas-widget.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-widget.c
--- ./foo-canvas-widget.c	Tue May 20 14:39:31 2003
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas-widget.c	Thu May 13 15:36:27 2004
@@ -1,3 +1,4 @@
+/*  Last edited: May 11 11:42 2004 (rnc) */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
  * All rights reserved.
@@ -452,8 +453,8 @@
 			witem->cwidth = (int) (witem->width + 0.5);
 			witem->cheight = (int) (witem->height + 0.5);
 		} else {
-			witem->cwidth = (int) (witem->width * item->canvas->pixels_per_unit + 0.5);
-			witem->cheight = (int) (witem->height * item->canvas->pixels_per_unit + 0.5);
+			witem->cwidth = (int) (witem->width * item->canvas->pixels_per_unit_x + 0.5);
+			witem->cheight = (int) (witem->height * item->canvas->pixels_per_unit_y + 0.5);
 		}
 
 		gtk_widget_set_usize (witem->widget, witem->cwidth, witem->cheight);
@@ -494,8 +495,8 @@
 
 	foo_canvas_c2w (item->canvas, witem->cx, witem->cy, &x1, &y1);
 
-	x2 = x1 + (witem->cwidth - 1) / item->canvas->pixels_per_unit;
-	y2 = y1 + (witem->cheight - 1) / item->canvas->pixels_per_unit;
+	x2 = x1 + (witem->cwidth - 1) / item->canvas->pixels_per_unit_x;
+	y2 = y1 + (witem->cheight - 1) / item->canvas->pixels_per_unit_y;
 
 	/* Is point inside widget bounds? */
 
Only in .: foo-canvas-widget.h
diff -u ./foo-canvas.c /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas.c
--- ./foo-canvas.c	Wed Oct 20 14:53:43 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas.c	Fri Feb 11 16:31:03 2005
@@ -1,3 +1,4 @@
+/*  Last edited: Feb 11 16:31 2005 (rds) */
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: 8; c-basic-offset: 8 -*- */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
@@ -290,7 +291,7 @@
 redraw_and_repick_if_mapped (FooCanvasItem *item)
 {
 	if (item->object.flags & FOO_CANVAS_ITEM_MAPPED) {
-		foo_canvas_item_request_redraw (item);
+	        foo_canvas_item_request_redraw (item);
 		item->canvas->need_repick = TRUE;
 	}
 }
@@ -1535,10 +1536,10 @@
 			has_point = TRUE;
 		} else
 			has_point = FALSE;
-
+		/* guessing that the x factor is OK here. RNGC */
 		if (has_point
 		    && point_item
-		    && ((int) (dist * item->canvas->pixels_per_unit + 0.5)
+		    && ((int) (dist * item->canvas->pixels_per_unit_x + 0.5)
 			<= item->canvas->close_enough)) {
 			best = dist;
 			*actual_item = point_item;
@@ -2074,7 +2075,8 @@
 	canvas->scroll_x2 = canvas->layout.width;
 	canvas->scroll_y2 = canvas->layout.height;
 
-	canvas->pixels_per_unit = 1.0;
+	canvas->pixels_per_unit_x = 1.0;
+	canvas->pixels_per_unit_y = 1.0;
 
 	canvas->pick_event.type = GDK_LEAVE_NOTIFY;
 	canvas->pick_event.crossing.x = 0;
@@ -2294,8 +2296,8 @@
 	canvas_width = GTK_WIDGET (canvas)->allocation.width;
 	canvas_height = GTK_WIDGET (canvas)->allocation.height;
 
-	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit + 0.5);
-	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit + 0.5);
+	scroll_width = floor ((canvas->scroll_x2 - canvas->scroll_x1) * canvas->pixels_per_unit_x + 0.5);
+	scroll_height = floor ((canvas->scroll_y2 - canvas->scroll_y1) * canvas->pixels_per_unit_y + 0.5);
 
 	right_limit = scroll_width - canvas_width;
 	bottom_limit = scroll_height - canvas_height;
@@ -2782,12 +2784,12 @@
 
 	canvas = FOO_CANVAS (widget);
 	
-	if (emit_event (canvas, (GdkEvent *) event))
-		return TRUE;
-	if (event->type == GDK_KEY_RELEASE)
-		return GTK_WIDGET_CLASS (canvas_parent_class)->key_release_event (widget, event);
-	else
-		return GTK_WIDGET_CLASS (canvas_parent_class)->key_press_event (widget, event);
+ 	if (emit_event (canvas, (GdkEvent *) event))
+ 		return TRUE;
+ 	if (event->type == GDK_KEY_RELEASE)
+ 		return GTK_WIDGET_CLASS (canvas_parent_class)->key_release_event (widget, event);
+ 	else
+ 		return GTK_WIDGET_CLASS (canvas_parent_class)->key_press_event (widget, event);
 }
 
 
@@ -2967,13 +2969,13 @@
 add_idle (FooCanvas *canvas)
 {
 	if (!canvas->idle_id) {
-		/* We let the update idle handler have higher priority
-		 * than the redraw idle handler so the canvas state
-		 * will be updated during the expose event.  canvas in
-		 * expose_event.
+ 		/* We let the update idle handler have higher priority
+ 		 * than the redraw idle handler so the canvas state
+ 		 * will be updated during the expose event.  canvas in
+ 		 * expose_event.
 		 */
 		canvas->idle_id = g_idle_add_full (GDK_PRIORITY_REDRAW - 20,
-						   idle_handler, canvas, NULL);
+ 						   idle_handler, canvas, NULL);
 	}
 }
 
@@ -3093,15 +3095,35 @@
 
 /**
  * foo_canvas_set_pixels_per_unit:
- * @canvas: A canvas.
+ * @canvas: A canvas
  * @n: The number of pixels that correspond to one canvas unit.
  *
  * Sets the zooming factor of a canvas by specifying the number of pixels that
  * correspond to one canvas unit.
+ * This is retained for backwards compatibility and just calls
+ * foo_canvas_set_pixels_per_unit_xy, passing the number of pixels/unit twice.
  **/
 void
 foo_canvas_set_pixels_per_unit (FooCanvas *canvas, double n)
 {
+  foo_canvas_set_pixels_per_unit_xy(canvas, n, n);
+  return;
+}
+
+
+/**
+ * foo_canvas_set_pixels_per_unit_xy:
+ * @canvas: A canvas.
+ * @x: The number of pixels that correspond to one canvas unit on the x axis.
+ * @y: The number of pixels that correspond to one canvas unit on the y axis.
+ *
+ * Sets the zooming factor of a canvas by specifying the number of pixels that
+ * correspond to one canvas unit.
+ * Having two zooming factors enables asymmetric zooming.
+ **/
+void
+foo_canvas_set_pixels_per_unit_xy (FooCanvas *canvas, double x, double y)
+{
 	GtkWidget *widget;
 	double cx, cy;
 	int x1, y1;
@@ -3111,7 +3133,8 @@
 	gint attributes_mask;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
-	g_return_if_fail (n > FOO_CANVAS_EPSILON);
+	/* guessing that the x factor is OK here.  RNCG */
+	g_return_if_fail (x > FOO_CANVAS_EPSILON);
 
 	widget = GTK_WIDGET (canvas);
 
@@ -3119,14 +3142,15 @@
 	center_y = widget->allocation.height / 2;
 
 	/* Find the coordinates of the screen center in units. */
-	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit + canvas->scroll_x1 + canvas->zoom_xofs;
-	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit + canvas->scroll_y1 + canvas->zoom_yofs;
+	cx = (canvas->layout.hadjustment->value + center_x) / canvas->pixels_per_unit_x + canvas->scroll_x1 + canvas->zoom_xofs;
+	cy = (canvas->layout.vadjustment->value + center_y) / canvas->pixels_per_unit_y + canvas->scroll_y1 + canvas->zoom_yofs;
 
 	/* Now calculate the new offset of the upper left corner. (round not truncate) */
-	x1 = ((cx - canvas->scroll_x1) * n) - center_x + .5;
-	y1 = ((cy - canvas->scroll_y1) * n) - center_y + .5;
+	x1 = ((cx - canvas->scroll_x1) * x) - center_x + .5;
+	y1 = ((cy - canvas->scroll_y1) * y) - center_y + .5;
 
-	canvas->pixels_per_unit = n;
+	canvas->pixels_per_unit_x = x;
+	canvas->pixels_per_unit_y = y;
 
 	if (!(canvas->root->object.flags & FOO_CANVAS_ITEM_NEED_DEEP_UPDATE)) {
 		canvas->root->object.flags |= FOO_CANVAS_ITEM_NEED_DEEP_UPDATE;
@@ -3260,7 +3284,8 @@
 	foo_canvas_w2c (canvas, x, y, &cx, &cy);
 
 	dist = foo_canvas_item_invoke_point (canvas->root, x, y, cx, cy, &item);
-	if ((int) (dist * canvas->pixels_per_unit + 0.5) <= canvas->close_enough)
+	/* guessing the x factor is OK here.  RNGC */
+	if ((int) (dist * canvas->pixels_per_unit_x + 0.5) <= canvas->close_enough)
 		return item;
 	else
 		return NULL;
@@ -3323,16 +3348,17 @@
 void
 foo_canvas_w2c (FooCanvas *canvas, double wx, double wy, int *cx, int *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 	
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = floor ((wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs + 0.5);
+		*cx = floor ((wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs + 0.5);
 	if (cy)
-		*cy = floor ((wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs + 0.5);
+		*cy = floor ((wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs + 0.5);
 }
 
 /**
@@ -3372,16 +3398,17 @@
 void
 foo_canvas_w2c_d (FooCanvas *canvas, double wx, double wy, double *cx, double *cy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (cx)
-		*cx = (wx - canvas->scroll_x1)*zoom + canvas->zoom_xofs;
+		*cx = (wx - canvas->scroll_x1)*zoom_x + canvas->zoom_xofs;
 	if (cy)
-		*cy = (wy - canvas->scroll_y1)*zoom + canvas->zoom_yofs;
+		*cy = (wy - canvas->scroll_y1)*zoom_y + canvas->zoom_yofs;
 }
 
 
@@ -3398,16 +3425,17 @@
 void
 foo_canvas_c2w (FooCanvas *canvas, int cx, int cy, double *wx, double *wy)
 {
-	double zoom;
+	double zoom_x, zoom_y;
 
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
-	zoom = canvas->pixels_per_unit;
+	zoom_x = canvas->pixels_per_unit_x;
+	zoom_y = canvas->pixels_per_unit_y;
 	
 	if (wx)
-		*wx = (cx - canvas->zoom_xofs)/zoom + canvas->scroll_x1;
+		*wx = (cx - canvas->zoom_xofs)/zoom_x + canvas->scroll_x1;
 	if (wy)
-		*wy = (cy - canvas->zoom_yofs)/zoom + canvas->scroll_y1;
+		*wy = (cy - canvas->zoom_yofs)/zoom_y + canvas->scroll_y1;
 }
 
 
@@ -3433,11 +3461,11 @@
 
 	if (worldx)
 		*worldx = canvas->scroll_x1 + ((winx - canvas->zoom_xofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_x);
 
 	if (worldy)
 		*worldy = canvas->scroll_y1 + ((winy - canvas->zoom_yofs)
-					       / canvas->pixels_per_unit);
+					       / canvas->pixels_per_unit_y);
 }
 
 
@@ -3460,10 +3488,10 @@
 	g_return_if_fail (FOO_IS_CANVAS (canvas));
 
 	if (winx)
-		*winx = (canvas->pixels_per_unit)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
+		*winx = (canvas->pixels_per_unit_x)*(worldx - canvas->scroll_x1) + canvas->zoom_xofs;
 
 	if (winy)
-		*winy = (canvas->pixels_per_unit)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
+		*winy = (canvas->pixels_per_unit_y)*(worldy - canvas->scroll_y1) + canvas->zoom_yofs;
 }
 
 
diff -u ./foo-canvas.h /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas.h
--- ./foo-canvas.h	Tue Mar  2 14:32:55 2004
+++ /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/foo-canvas.h	Thu May 13 15:36:18 2004
@@ -1,3 +1,4 @@
+/*  Last edited: May 12 08:36 2004 (rnc) */
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: 8; c-basic-offset: 8 -*- */
 /*
  * Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
@@ -371,7 +372,8 @@
 	double scroll_x2, scroll_y2;
 
 	/* Scaling factor to be used for display */
-	double pixels_per_unit;
+	double pixels_per_unit_x;
+	double pixels_per_unit_y;
 
 	/* Idle handler ID */
 	guint idle_id;
@@ -456,6 +458,10 @@
 /* Sets the number of pixels that correspond to one unit in world coordinates */
 void foo_canvas_set_pixels_per_unit (FooCanvas *canvas, double n);
 
+/* Sets the number of  pixels corresponding to one unit in world coordinates
+ * separately on x and y axes, allowing asymmetric zooming. */
+void foo_canvas_set_pixels_per_unit_xy (FooCanvas *canvas, double x, double y);
+
 /* Wether the canvas centers the scroll region if it is smaller than the window  */
 void foo_canvas_set_center_scroll_region (FooCanvas *canvas, gboolean center_scroll_region);
 
Only in .: libfoocanvas.h
Only in .: libfoocanvas.pc.in
Only in .: libfoocanvastypes.c
Only in /nfs/team71/analysis/rds/workspace/ZMap/foocanvas/: support
